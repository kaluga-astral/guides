{"searchDocs":[{"title":"contract-first","type":0,"sectionRef":"#","url":"/guides/docs/arch/contract-first","content":"contract-first","keywords":"","version":"Next"},{"title":"domain","type":0,"sectionRef":"#","url":"/guides/docs/arch/modules/domain","content":"domain","keywords":"","version":"Next"},{"title":"Intro","type":0,"sectionRef":"#","url":"/guides/docs/arch/intro","content":"","keywords":"","version":"Next"},{"title":"Особенности​","type":1,"pageTitle":"Intro","url":"/guides/docs/arch/intro#особенности","content":" Ориентированность на решение задач бизнесаСтруктура проекта позволяет быстро понять решаемые проектом задачиНезависимость приложения от фреймворка и используемых библиотекНезависимость от способа получения данныхОтделение бизнес/ui логики от view слоя увеличивает уровень переиспользования компонентов системыИспользование DI концепции позволяет избежать высокого уровня зацепленияПростота тестирования программных модулей системыВозможность постепенного внедрения в проектВозможность освоить подход разработчику, знакомому с базовыми принципами проектирования  Astral Architecture Guide использует проверенные временем концепции (Clean architecture, DDD, SOLID) для построения масштабируемого решения frontend-проектов.    ","version":"Next","tagName":"h2"},{"title":"Область применения​","type":1,"pageTitle":"Intro","url":"/guides/docs/arch/intro#область-применения","content":" Стоит применять для проектов:  Содержащих бизнес-логику и работу с даннымиС долгим циклом разработки и поддержки  Не подходит для:  ЛэндинговПроектов, которые не планируется поддерживать  Методология не привязана к конкретному стэку.    ","version":"Next","tagName":"h2"},{"title":"Предпосылки создания и введение в архитектурную концепцию​","type":1,"pageTitle":"Intro","url":"/guides/docs/arch/intro#предпосылки-создания-и-введение-в-архитектурную-концепцию","content":" Предметно-ориентированная архитектура frontend приложений - Андрей Потемкин - Frontend Meetup  ","version":"Next","tagName":"h2"},{"title":"Обзор архитектуры​","type":1,"pageTitle":"Intro","url":"/guides/docs/arch/intro#обзор-архитектуры","content":" Astral Architecture Guide состоит из архитектурных слоев, некоторые слои делятся на сегменты.    Зависимости между слоями/сегментами приложения направлены сверху вниз.  Нижестоящий слой/сегмент ничего не должен знать о вышестоящем.  Пример структуры проекта:  ├── app/ ├── screens/ ├── modules/ ├── data/ └── shared/   ","version":"Next","tagName":"h2"},{"title":"Краткий обзор архитектуры​","type":1,"pageTitle":"Intro","url":"/guides/docs/arch/intro#краткий-обзор-архитектуры","content":" Рекомендуется в первую очередь ознакомиться с Кратким обзором архитектуры, а зачем перейти к подробному обзору разделов документации. ","version":"Next","tagName":"h3"},{"title":"Зависимости фичей","type":0,"sectionRef":"#","url":"/guides/docs/arch/modules/features/dependencies","content":"","keywords":"","version":"Next"},{"title":"Переиспользуемые фичи​","type":1,"pageTitle":"Зависимости фичей","url":"/guides/docs/arch/modules/features/dependencies#переиспользуемые-фичи","content":" Есть ситуации, когда между фичами необходимо переиспользовать компонент, но интеграция подобных фичей на уровне screen является неоправданно сложной.  В таких случаях допускается выделение компонента в третью фичу и использования ее внутри других фичей.  Пример  В CardPayment и CashPayment фичах есть идентичные поля для ввода ФИО. Компонент для для ввода ФИО выносится в третью фичу FullnameField .    ","version":"Next","tagName":"h2"},{"title":"Интеграция фич​","type":1,"pageTitle":"Зависимости фичей","url":"/guides/docs/arch/modules/features/dependencies#интеграция-фич","content":" Для интеграции фич используется слой screens.  Подробный обзор Screens   ","version":"Next","tagName":"h2"},{"title":"domain","type":0,"sectionRef":"#","url":"/guides/docs/arch/modules/features/domain","content":"domain","keywords":"","version":"Next"},{"title":"Style Guide","type":0,"sectionRef":"#","url":"/guides/docs/arch/modules/features/style-guide","content":"Style Guide Features | Astral.Frontend Style Guide","keywords":"","version":"Next"},{"title":"Обзор Features","type":0,"sectionRef":"#","url":"/guides/docs/arch/modules/features/overview","content":"Обзор Features Каждый модуль предоставляет набор фич, комбинация которых формирует экраны приложения (screens) или другие фичи. Feature - это готовый для использования компонент, решающий свою задачу. Благодаря Features, любой член команды (даже не разработчик) может легко и быстро определить, какие возможности и функции предоставляет данное приложение, просто взглянув на названия директорий. Пример структуры: ├── app/ ├── screens/ ├── modules/ | └── payment/ | | ├── features/ | | | ├── PaymentSwitch/ | | | ├── CardPayment/ | | | ├── CashPayment/ | | | └── index.ts | | ├── domain/ | | └── index.ts ├── data/ └── shared/ Feature может быть как полноценной частью системы с сокрытой внутри логикой, так и ui компонентом, отображающим данные. Feature содержит в себе все необходимое для своего функционирования: UI компонент, отвечающий только за отрисовку фичи. В компоненте не реализуется никакая логикаЛогику фичи. Вся логика фичи, включая ui-логику, реализуется вне ui компонентаСтили компонентаДругие UI компоненты, входящие в состав основного компонентаДругие программные сущности необходимые для корректной работы фичи Пример структуры фичи на React стэке: ├── app/ ├── screens/ ├── modules/ | └── payment/ | | ├── PaymentSwitch/ | | | ├── PaymentSwitch.tsx | | | ├── PaymentSwitch.test.tsx | | | ├── SwitchBtn/ | | | ├── styles.ts | | | ├── utils/ | | | ├── UIStore/ | | | ├── constants.ts | | | ├── types.ts | | | └── index.ts | | ├── CardPayment/ | | ├── CashPayment/ | | └── index.ts | ├── domain/ | └── index.ts ├── data/ └── shared/ ","keywords":"","version":"Next"},{"title":"Тестирование","type":0,"sectionRef":"#","url":"/guides/docs/arch/modules/features/testing","content":"","keywords":"","version":"Next"},{"title":"Тестирование логики​","type":1,"pageTitle":"Тестирование","url":"/guides/docs/arch/modules/features/testing#тестирование-логики","content":" В features обязательно необходимо тестировать слой логики.  Преимущества отдельного тестирования логики feature:  Возможность переиспользования логики фичи, без необходимости переноса и рефакторинга тестов. Слой логики не зависит от ui, поэтому на уровне архитектурной концепции для логики должны быть отдельные тестыПростота реализации тестов для слоя логики. Для реализации тестов логики нет необходимости использовать дополнительные инструменты или эмуляцию браузерного окруженияБыстрота выполнения тестов. Логика не зависит от ui, поэтому эмулировать браузерное окружение не нужно, это значительно сокращает время выполнения тестов  ","version":"Next","tagName":"h2"},{"title":"Требования к тестам логики​","type":1,"pageTitle":"Тестирование","url":"/guides/docs/arch/modules/features/testing#требования-к-тестам-логики","content":" Тесты логики features подчиняются единым требованиям:  Astral.Frontend Unit Testing Guide  ","version":"Next","tagName":"h3"},{"title":"Работа с Repositories и faker​","type":1,"pageTitle":"Тестирование","url":"/guides/docs/arch/modules/features/testing#работа-с-repositories-и-faker","content":" Тестирование SUT, использующих Repositories  ","version":"Next","tagName":"h3"},{"title":"Формирование тест-кейсов​","type":1,"pageTitle":"Тестирование","url":"/guides/docs/arch/modules/features/testing#формирование-тест-кейсов","content":" Тестирование бизнес-логики    ","version":"Next","tagName":"h3"},{"title":"Тестирование ui​","type":1,"pageTitle":"Тестирование","url":"/guides/docs/arch/modules/features/testing#тестирование-ui","content":" Если для слоя логики были реализованы тесты, то тестирование слоя ui можно либо опустить, либо проверять только:  Условный рендерингВзаимодействие с браузерным окружением (ожидаемая обработка кликов, работа с ref, window и т.п.)  От тестирования ui в features можно отказаться по причинам:  Большая часть ключевых кейсов будет уже проверена на слое логики. Стоит избегать дублирования тестовТесты для ui - это интеграционное тестирование. Интеграционное тестирование сложнее в реализацииТесты для ui медленные потому, что необходимо эмулировать браузерное окруженияДля удобных и устойчивых к рефакторингу тестов ui необходимо применять DI для компонентов, это усложнит взаимодействие с features и их инициализацию    ","version":"Next","tagName":"h2"},{"title":"Тестирование форм​","type":1,"pageTitle":"Тестирование","url":"/guides/docs/arch/modules/features/testing#тестирование-форм","content":" Тестирование форм ","version":"Next","tagName":"h2"},{"title":"Отделение логики от view","type":0,"sectionRef":"#","url":"/guides/docs/arch/modules/features/UILogic/overview","content":"","keywords":"","version":"Next"},{"title":"Мотивация​","type":1,"pageTitle":"Отделение логики от view","url":"/guides/docs/arch/modules/features/UILogic/overview#мотивация","content":" Отделение view слоя от логики дает следующие преимущества:  Возможность изменять логику и ui независимоПростота переиспользования логики или ui по необходимостиНезависимость от используемого фреймворка. Фреймворк при определенных обстоятельствах можно заменить, а логику переиспользоватьПростота тестирования. Можно тестировать отдельно логику и uiОднозначность расположения логики. Вся логика всегда находится в одном местеЛогика не “размазывается” по компонентам. Избавляет от сложностей в поддержке кодаПовышение читаемости кодаУпрощение поддержки и доработки приложения  ","version":"Next","tagName":"h2"},{"title":"UI компонент​","type":1,"pageTitle":"Отделение логики от view","url":"/guides/docs/arch/modules/features/UILogic/overview#ui-компонент","content":" Компонент должен содержать только то, что непосредственно связано с фреймворком, ответственным за отображение.  В ui компоненте не должно находится:  Логики форматирования данных для отображенияЛогики работы с даннымиФлагов, отвечающих за отображение частей ui  В ui компоненте должно находится:  Работа с браузерным APIРабота со спецификой фреймворка Обработка пользовательского ввода с целью передачи данных в логикуРабота с DOM Потребление данных из логики для их отображенияКоннект методов логики с обработкой пользовательского ввода и браузерных событий  UI компонент потребляет логику фичи и полностью зависит от ее интерфейсов.  ","version":"Next","tagName":"h2"},{"title":"Логика​","type":1,"pageTitle":"Отделение логики от view","url":"/guides/docs/arch/modules/features/UILogic/overview#логика","content":" В рамках features бизнес-логика и ui логика не разделяется.  Логика в feature содержит:  Формирование данных для отображения в uiРаботу с данными, взаимодействие с Data слоемРаботу с флагами, которые в компоненте будут ответственны за отображение компонента (например, удаление из DOM, изменение цвета и т.п.)  Логика фичи не должна зависеть от ui компонента. Зависимости направлены от ui к логике:    Логика может быть реализована на любом предпочтительном стэке с использованием:  state managerhook (React стэк)serviceutils  ","version":"Next","tagName":"h2"},{"title":"Мотивация объединения бизнес и ui логики в фиче​","type":1,"pageTitle":"Отделение логики от view","url":"/guides/docs/arch/modules/features/UILogic/overview#мотивация-объединения-бизнес-и-ui-логики-в-фиче","content":" Если оставлять ui логику в компоненте, то велика вероятность просачивания бизнес логики в компонентВ реальном проекте зачастую достаточно сложно решить что относится к бизнес логике, а что относится к ui. Возникают ситуации, когда разработчики замедляются в реализации фичи из-за дилеммы: куда поместить эту логику? В компонент или в store?  ","version":"Next","tagName":"h3"},{"title":"State manager для реализации логики​","type":1,"pageTitle":"Отделение логики от view","url":"/guides/docs/arch/modules/features/UILogic/overview#state-manager-для-реализации-логики","content":" Для реализации логики рекомендуется использовать state manager.  State manager позволит:  Не завязываться на специфику ui фреймворкаИзбежать нежелательных зависимостей от ui. Технически невозможно в state manager поместить специфику ui фреймворкаПисать простые тесты для логикиПростота распространения данных в приложении  ","version":"Next","tagName":"h3"},{"title":"Использование react hooks для реализации логики​","type":1,"pageTitle":"Отделение логики от view","url":"/guides/docs/arch/modules/features/UILogic/overview#использование-react-hooks-для-реализации-логики","content":" Желательно избегать использования react hooks для реализации логики. Так как hooks - это часть react, то в них доступны все методы по работе с ui, это значит в логику проникнет специфика фреймворка.  Из этого могут возникнуть проблемы:  Невозможность переиспользования логики в другом стэкеСмешивание ui и логики. Без контроля в hooks будет попадать логика работы с ref, react событиями и т.п.Невозможность переиспользования логики из-за косвенной зависимости от uiСложность работы с глобальными даннымиСложность тестирования. Для тестирования hooks необходимы дополнительные инструменты (react-testing-library, jsdom | happydom)  ","version":"Next","tagName":"h3"},{"title":"Переиспользование логики между фичами​","type":1,"pageTitle":"Отделение логики от view","url":"/guides/docs/arch/modules/features/UILogic/overview#переиспользование-логики-между-фичами","content":" Логику необходимо выносить в Domain , если логику, реализованную внутри фичи, потребовалось:  Переиспользовать в другой фичеПереиспользовать в другом модулеИспользовать для интеграции с другой фичей  Подробный обзор Domain  ","version":"Next","tagName":"h3"},{"title":"Использование DI для контроля зависимостей​","type":1,"pageTitle":"Отделение логики от view","url":"/guides/docs/arch/modules/features/UILogic/overview#использование-di-для-контроля-зависимостей","content":" Логика должна использовать базовую концепцию DI (dep. injection) для того, чтобы контролировать свои зависимости.  Плюсы подхода:  Логику проще поддерживать за счет того, что нет скрытых зависимостей. Все зависимости сразу видны и очевидныЛогику проще тестировать. Зависимости можно просто подменять на тестовые сущности  Пример  import { makeAutoObservable } from 'mobx'; import { CartStore } from '@astral/modules/cart'; export class CatalogStore { constructor(private readonly cartStore: CartStore) { makeAutoObservable(this, {}, { autoBind: true }); } addToCart = (productID: string) =&gt; { this.cartStore.add(productID); }; }   ","version":"Next","tagName":"h3"},{"title":"Демонстрация профита отделения ui и логики​","type":1,"pageTitle":"Отделение логики от view","url":"/guides/docs/arch/modules/features/UILogic/overview#демонстрация-профита-отделения-ui-и-логики","content":" Представим, что у нас есть блок, в котором происходит оплата услуги по карте.  Данный блок является фичей CardPayment в модуле Payment.  Сейчас фича производит оплату через конкретную платежную систему после успешной оплаты отправляем нашему API данные.  Через некоторое время появилась необходимость реализовать новую фичу, ui которой должен повторять CardPayment, но при этом должна использоваться другая платежная система и после оплаты данные отправляются на другое API.  Так как мы сразу отделили логику и ui компонент, то мы можем без особых проблем вынести исходную логику CardPayment в Domain и использовать для CardPayment один и тот же ui, но разную логику. ","version":"Next","tagName":"h2"},{"title":"overview","type":0,"sectionRef":"#","url":"/guides/docs/arch/modules/features/UIStore/overview","content":"overview","keywords":"","version":"Next"},{"title":"Render компонентов в store","type":0,"sectionRef":"#","url":"/guides/docs/arch/modules/features/UIStore/renderComponentInStore","content":"Render компонентов в store","keywords":"","version":"Next"},{"title":"overview","type":0,"sectionRef":"#","url":"/guides/docs/arch/modules/features/useLogic/overview","content":"overview","keywords":"","version":"Next"},{"title":"screens","type":0,"sectionRef":"#","url":"/guides/docs/arch/screens","content":"screens","keywords":"","version":"Next"},{"title":"Shared","type":0,"sectionRef":"#","url":"/guides/docs/arch/shared","content":"","keywords":"","version":"Next"},{"title":"Основная концепция​","type":1,"pageTitle":"Shared","url":"/guides/docs/arch/shared#основная-концепция","content":"   Shared слой содержит переиспользуемые программные сущности, не относящиеся к предметной области проекта.  Назначение Shared: защита приложения от низкоуровневых реализаций, включая библиотеки.  Shared можно рассматривать как слой, который можно вынести в npm пакет и использовать на других проектах с другой предметной областью.  В Shared могут находится:  constants общие для всего приложения, но не относящиеся к предметной областиtypesutilsservicesstorescomponentshooks…  Если программная сущность каким-либо образом связана с предметной областью проекта, то она должна быть помещена в Modules.  Пример структуры Shared для React стэка:  ├── app/ ├── screens/ ├── modules/ ├── data/ └── shared/ | ├── constants/ | ├── types/ | ├── utils/ | ├── services/ | ├── stores/ | ├── ui/ | | ├── components/ | | ├── hooks/ | | ├── external.ts | | └── index.ts | └── index.ts   ","version":"Next","tagName":"h2"},{"title":"Доступность Shared​","type":1,"pageTitle":"Shared","url":"/guides/docs/arch/shared#доступность-shared","content":" Shared слой доступен для использования во всех слоя приложения.    ","version":"Next","tagName":"h2"},{"title":"Независимость от библиотек​","type":1,"pageTitle":"Shared","url":"/guides/docs/arch/shared#независимость-от-библиотек","content":" Shared позволяет не зависеть от библиотек в других слоях, применяя к ним DI (dep. inversion).  Никакой другой слой не должен напрямую импортировать библиотеку. Есть исключения, для которых инвертирование зависимостей сделать сложно (например, react).  В Shared все внешние зависимости должны контролироваться через external.ts файлы. external.ts реэкспортируют внешние зависимости.  ├── app/ ├── screens/ ├── modules/ ├── data/ └── shared/ | ├── constants/ | ├── types/ | ├── utils/ | | ├── formatDate/ | | ├── external.ts | | └── index.ts | ├── services/ | ├── stores/ | ├── ui/ | └── index.ts   Благодаря реэкпорту зависимостей в shared мы можем без особых проблем заменить одну библиотеку или реализацию на другую, при этом не внося изменения в другие слои приложения.  Пример 1  На проекте используется date-fns для работы с датами, появилась потребность в переходе на dayjs.  Благодаря тому, что приложение не взаимодействует напрямую с date-fns в shared можно изменить реализацию методов для работы с датами на dayjs, оставив исходный интерфейс методов.  Пример 2  На проекте используется mui в качестве ui библиотеки.  Потребовалась кастомизация компонента Button.  Для кастомизации нам потребуется внести изменения в shared, при этом в другие слои приложения правки вносить не надо.    ","version":"Next","tagName":"h2"},{"title":"Тестирование​","type":1,"pageTitle":"Shared","url":"/guides/docs/arch/shared#тестирование","content":" Тесты в shared подчиняются единым требованиям:  Astral.Frontend Unit Testing Guide  Shared - это инфраструктурный слой, доступный во всех слоях приложения.  Поэтому в shared тестами должны быть покрыты все программные сущности, содержащие логику.  ","version":"Next","tagName":"h2"},{"title":"Тестирование ui​","type":1,"pageTitle":"Shared","url":"/guides/docs/arch/shared#тестирование-ui","content":" Если ui компоненты shared содержат логику, то ui должен быть протестирован с помощью соответствующего инструмента (например, @testing-library/react).  Данная концепция отличается от тестирования features потому, что shared не содержит бизнес-логики.  ","version":"Next","tagName":"h3"},{"title":"Взаимодействие с библиотеками​","type":1,"pageTitle":"Shared","url":"/guides/docs/arch/shared#взаимодействие-с-библиотеками","content":" Поведение внешних библиотек тестироваться не должно. Причина: внешняя библиотека уже должны быть протестирована, мы должны ей доверять, если используем.  Мокать внешние библиотеки не нужно. Исключение: библиотека взаимодействует с внешними источниками данных.  ","version":"Next","tagName":"h3"},{"title":"Формирование тест-кейсов​","type":1,"pageTitle":"Shared","url":"/guides/docs/arch/shared#формирование-тест-кейсов","content":" Unit-тесты | Astral.Frontend Style Guide ","version":"Next","tagName":"h3"},{"title":"Обзор Modules","type":0,"sectionRef":"#","url":"/guides/docs/arch/modules/overview","content":"","keywords":"","version":"Next"},{"title":"Мотивация​","type":1,"pageTitle":"Обзор Modules","url":"/guides/docs/arch/modules/overview#мотивация","content":" Для качественной реализации бизнес требований необходимо учитывать особенности предметной области проекта. Она состоит из набора понятий, сущностей и процессов, которые являются фундаментом разработки.  Однако, по мере роста функционала приложения, список концепций предметной области может стать слишком большим и запутанным. Концепции могут стать расплывчатыми, а модели предметной области сложными и неуправляемыми. Это приводит к тому, что приложение становится похожим на &quot;Big ball of mud” (большой комок грязи).    Для решения описанной проблемы в Astral Architecture Guide применяются методы стратегического проектирования DDD (Domain Driven Design).  ","version":"Next","tagName":"h2"},{"title":"Разбиение предметной области на модули​","type":1,"pageTitle":"Обзор Modules","url":"/guides/docs/arch/modules/overview#разбиение-предметной-области-на-модули","content":" Большая предметная область проекта разбивается на подобласти (модули). Каждая подобласть содержит в себе свой изолированный набор концепций.  Подобласти или модули - это изолированные наборы концепций, которые связаны между собой.  Преимущества использования данного метода:  Позволяет упростить восприятие модели предметной области, поскольку каждый модуль содержит только те концепции, которые ему необходимы. Это также способствует более четкому пониманию бизнес-требований и их реализации.Упрощает масштабирование приложения и улучшает его производительность. Если функционал приложения распределен по модулям, то разработчики могут работать над каждым модулем независимо друг от друга, что ускоряет процесс разработки.Способствует упрощению тестирования и сопровождения приложения. Если каждый модуль содержит только те концепции, которые ему необходимы, то тестирование каждого модуля становится более простым и эффективным.Позволяет распределить зоны ответственности команды и зоны влияния концепций.  ","version":"Next","tagName":"h2"},{"title":"Единый язык​","type":1,"pageTitle":"Обзор Modules","url":"/guides/docs/arch/modules/overview#единый-язык","content":" Для того чтобы каждый модуль был максимально понятен и согласован внутри команды разработчиков, важно использовать единый язык в рамках каждого модуля. Это означает, что каждый модуль должен иметь свой словарь терминов и понятий, которые используются внутри этого модуля.  При этом, одинаковые термины в разных модулях могут иметь разные значения. Например, в предметной области мониторинга ошибок (Sentry) в модуле авторизации и аутентификации User будет иметь одно значение и фичи, а в модуле отображение ошибок User’ом будет является пользователь приложения, в котором произошла ошибка.  Использование единого языка позволяет:  Уменьшить количество недопониманий и ошибок при разработке и поддержке кода.Улучшить коммуникацию между разработчиками и другими участниками проекта, такими как QA, менеджеры проекта и Backend.Избежать двойного трактования понятий.  ","version":"Next","tagName":"h3"},{"title":"Сегментирование модулей​","type":1,"pageTitle":"Обзор Modules","url":"/guides/docs/arch/modules/overview#сегментирование-модулей","content":"   Модуль содержит два сегмента:  Features. Фичи, поставляемые модулемDomain. Логика, поставляемая модулем  Пример структуры:  ├── app/ ├── screens/ ├── modules/ | └── payment/ | | ├── features/ | | ├── domain/ | | └── index.ts ├── data/ └── shared/   ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"Обзор Modules","url":"/guides/docs/arch/modules/overview#features","content":" Подробный обзор Features  ","version":"Next","tagName":"h3"},{"title":"Domain​","type":1,"pageTitle":"Обзор Modules","url":"/guides/docs/arch/modules/overview#domain","content":" Подробный обзор Domain  ","version":"Next","tagName":"h3"},{"title":"Зависимости модулей​","type":1,"pageTitle":"Обзор Modules","url":"/guides/docs/arch/modules/overview#зависимости-модулей","content":" Modules зависит от:  SharedDataДругих модулей    Зависимости от Shared и Data нет необходимости контролировать, они могут свободно использоваться в Modules.  Однако модули системы могут использовать features и domain друг друга. Важно контролировать зависимости между модулями и следить за тем, чтобы уровень зацепления был наименьшим.    Низкий уровень зацепления позволяет вносить изменения в модули без значительного влияния на остальные модули. Это означает, что при изменении логики в одном модуле, другие модули не будут затронуты. Это также способствует повторному использованию кода, так как каждый модуль может быть использован в других проектах или в других частях текущего проекта.  Для контроля зависимостей между модулями используются следующие концепции:  Использование index файлов для предоставления публичного API. Контроль поставляемых фичИспользование external файлов для контроля входящих зависимостей    ├── app/ ├── screens/ ├── modules/ | ├── payment/ | | ├── features/ | | ├── domain/ | | ├── external.ts # Входящие зависимости | | └── index.ts # Публичное API модуля ├── data/ └── shared/   ","version":"Next","tagName":"h2"},{"title":"Использование index файлов для предоставления публичного API​","type":1,"pageTitle":"Обзор Modules","url":"/guides/docs/arch/modules/overview#использование-index-файлов-для-предоставления-публичного-api","content":" Каждый модуль должен предоставлять публичное API: какие фичи модуль готов предоставлять приложению.  Для реализации данного подхода используются index файлы:  ├── app/ ├── screens/ ├── modules/ | ├── payment/ | | ├── features/ | | ├── domain/ | | └── index.ts # Публичное API модуля ├── data/ └── shared/   index.ts  export { CardPayment, CashPayment } from './features'; export { CardPaymentStore, CashPaymentStore, type PaymentType, } from './domain';   В данном примере модуль PaymentModule предоставляет для использования только то, что экспортируется из index.ts. Другие features и domain не доступны во вне модуля.  Импорты из модуля должны идти только через index  Valid:  import { CashPayment } from '@astral/modules/payment';   Invalid:  import { PayButton } from '@astral/modules/payment/features';   ","version":"Next","tagName":"h3"},{"title":"Использование external файлов для контроля входящих зависимостей.​","type":1,"pageTitle":"Обзор Modules","url":"/guides/docs/arch/modules/overview#использование-external-файлов-для-контроля-входящих-зависимостей","content":" Необходимо контролировать уровень зацепления между модулями.  Может произойти ситуация, когда один модуль сильно зацеплен с другим. Без промежуточного слоя это приведет к хрупкости одного из модулей - изменение одного модуля провоцирует изменения в другом.    Для решения данной проблемы каждый модуль должен явным образом описывать свои входные зависимости от других модулей через external файлы.    Благодаря external мы можем без усилий проследить за зависимостями модуля и при необходимости избавится от нежелательного зацепеления.  Пример  Payment модуль использует из Auth UserStore.  ├── app/ ├── screens/ ├── modules/ | ├── auth/ | ├── payment/ | | ├── features/ | | ├── domain/ | | ├── external.ts | | └── index.ts ├── data/ └── shared/   Payment должен делать импорт из Auth модуля только через external файл.  Valid  external.ts  export { UserStore } from '@astral/modules/auth';   Payment/features/CardPayment/store/store.ts  import { UserStore } from '../../../external'; ...   Invalid  Payment/features/CardPayment/store/store.ts  import { UserStore } from '@astral/modules/auth'; ...   ","version":"Next","tagName":"h3"},{"title":"Универсальные модули (Layout)​","type":1,"pageTitle":"Обзор Modules","url":"/guides/docs/arch/modules/overview#универсальные-модули-layout","content":" При проектировании модулей важно понимать, что существуют универсальные подобласти, которые напрямую не связаны с предметной областью проекта, но при этом содержат фичи из других модулей.  Примером такой области может являться Layout.  Layout приложения может содержать header, footer, PageLayout и т.п.  На первый взгляд данные фичи не относятся к предметной области проекта и должны быть помещены в shared. Но это не так. Layout может внутри себя содержать фичи из AuthModule для отображения на каждом screen пользовательских данных. Таким образом LayoutModule превращается в универсальный модуль потому, что косвенно связан с предметной областью проекта.  ├── app/ ├── screens/ ├── modules/ | ├── layout/ | | ├── features/ | | | ├── AppHeader/ | | | ├── AppFooter/ | | | ├── AppLayout/ | | | ├── PageLayout/ | | | ├── FormLayout/ | | | └── index.ts | | ├── domain/ | | └── index.ts ├── data/ └── shared/   При проектировании универсальных модулей важно определить их границы и не загружать их функциональностью, которая не относится к их основной цели.  Например, NoAccess фича не относится к Layout, подобная фича должна быть вынесена в AccessModule.  ","version":"Next","tagName":"h2"},{"title":"С чего начать​","type":1,"pageTitle":"Обзор Modules","url":"/guides/docs/arch/modules/overview#с-чего-начать","content":" В начале проектирования достаточно будет выделить два-три модуля, один из которых будет Layout.  По мере роста фичей в модуле вы сможете понять, что необходимо выделять отдельный модуль для набора фичей.  ","version":"Next","tagName":"h2"},{"title":"Пример проектирования модулей онлайн-магазина​","type":1,"pageTitle":"Обзор Modules","url":"/guides/docs/arch/modules/overview#пример-проектирования-модулей-онлайн-магазина","content":" Допустим, мы разрабатываем приложение для онлайн-магазина.  Модули​  Предметную область можно разбить на следующие модули:  Каталог товаров - содержит все, что связано с взаимодействием товара и покупателя. Фичами модуля могут быть поиск товаров по различным параметрам, фильтрация товаров по категориям и тегам.Корзина - отвечает за управление корзиной покупателя. Фичами модуля могут быть добавление товаров в корзину, изменение количества товаров и оформление заказа.Оплата - отвечает за обработку оплаты заказов в приложении. Фичами модуля могут быть выбор способа оплаты, ввод данных платежных карт, обработка платежей и отображение статуса оплаты для пользователя.Авторизация и регистрация - отвечает за управление пользователями. Фичами модуля могут быть регистрация новых пользователей, авторизация и управление профилем пользователя.Layout - отвечает за разметку блоков приложения.  ├── app/ ├── screens/ ├── modules/ | ├── catalog/ | ├── cart/ | ├── payment/ | ├── auth/ | └── layout/ ├── data/ └── shared/   Catalog Module​  Features  ├── app/ ├── screens/ ├── modules/ | ├── catalog/ | | ├── features/ | | | ├── CatalogList/ # Список товаров | | | ├── ProductPhoto/ # Фото товара. Является приватной фичей. | | | ├── CatalogCard/ # Карточка товара | | | ├── Filters/ # Фильтрация товаров | | | ├── SearchBar/ # Поиск товаров | | | └── index.ts | | ├── domain/ | | └── index.ts | ├── cart/ | ├── payment/ | ├── auth/ | ├── layout/ ├── data/ └── shared/   Зависимости фичей  CatalogCard должен содержать кнопку добавления товара в корзину. Добавление товара в корзину - это зона ответственности модуля Cart, именно там и находится ui кнопки добавления товара AddToCartButton и бизнес-логика добавления товара AddToCartStore.  AddToCartButton и AddToCartStore используются в CatalogCard.    Переиспользуемая фича ProductPhoto  ProductPhoto переиспользуется в CatalogList и CatalogCard.  При этом ProductPhoto не экспортируется из модуля Catalog, а значит недоступна в других модулях.  Cart Module​  ├── app/ ├── screens/ ├── modules/ | ├── catalog/ | ├── cart/ | | ├── features/ | | | ├── ShoppingList/ # Список товаров, добавленных в корзину | | | ├── OrderForm/ # Форма оформления заказа | | | ├── AddToCartButton/ # Кнопка добавления товара в корзину | | | ├── CartIconBtn/ # Иконка корзины с счетчиком | | | └── index.ts | | ├── domain/ | | | ├── stores/ | | | | ├── AddToCartStore/ # логика добавления товара | | | | └── index.ts | | | └── index.ts | | └── index.ts | ├── payment/ | ├── auth/ | ├── layout/ ├── data/ └── shared/   Payment Module​  В модуле payment у нас есть необходимость в переиспользовании логики оплаты картой и оплаты наличными, поэтому эта логика выносится в domain.  CardPaymentStore и CashPaymentStore используется внутри фич CardPayment, CashPayment, а также может быть использована в другом модуле, например, Cart.  ├── app/ ├── screens/ ├── modules/ | ├── catalog/ | ├── cart/ | ├── payment/ | | ├── features/ | | | ├── PaymentSwitch/ # Выбор способа оплаты | | | ├── CardPayment/ # Оплата картой | | | ├── CashPayment/ # Оплата наличными | | | └── index.ts | | ├── domain/ | | | ├── stores/ | | | | ├── CardPaymentStore/ # Логика оплаты картой | | | | ├── CashPaymentStore/ # Логика оплаты наличными | | | | └── index.ts | | | └── index.ts | | └── index.ts | ├── auth/ | ├── layout/ ├── data/ └── shared/   Layout Module​  Layout нашего для каждой страницы состоит из: header, footer, sidebar.  В header для отображения иконки с корзиной и счетчика товаров используется CartIconBtn из Cart модуля. При этом для каждого screen в header будет свой title.  Нам необходимо в screens переиспользовать AppLayout, который будет содержать CartIconBtn и предоставлять возможность на каждой странице добавлять свой title в AppLayout.  Это означает, что наш Layout связан с предметной областью проекта и поэтому для Layout’ов выделяется отдельный модуль.  ├── app/ ├── screens/ ├── modules/ | ├── catalog/ | ├── cart/ | ├── payment/ | ├── auth/ | ├── layout/ | | ├── features/ | | | ├── AppLayout/ # Layout приложения | | | ├── PageLayout/ # Layout каждой страницы | | | ├── FormLayout/ # Layout форм | | | └── index.ts | | └── index.ts ├── data/ └── shared/   ","version":"Next","tagName":"h2"},{"title":"Результат​","type":1,"pageTitle":"Обзор Modules","url":"/guides/docs/arch/modules/overview#результат","content":" https://github.com/kaluga-astral/vite-boilerplate    ","version":"Next","tagName":"h3"},{"title":"Style Guide​","type":1,"pageTitle":"Обзор Modules","url":"/guides/docs/arch/modules/overview#style-guide","content":" Modules | Astral.Frontend Style Guide ","version":"Next","tagName":"h2"},{"title":"Краткий обзор архитектуры","type":0,"sectionRef":"#","url":"/guides/docs/arch/overview","content":"","keywords":"","version":"Next"},{"title":"Shared. Независимость от низкоуровневых реализаций и библиотек​","type":1,"pageTitle":"Краткий обзор архитектуры","url":"/guides/docs/arch/overview#shared-независимость-от-низкоуровневых-реализаций-и-библиотек","content":"   Shared слой содержит переиспользуемые программные сущности, не относящиеся к предметной области проекта.  Shared позволяет приложению не зависеть от низкоуровневых реализаций, включая библиотек.  Shared можно рассматривать как слой, который можно вынести в npm пакет и использовать на других проектах с другой предметной областью.  Пример структуры Shared для React стэка:  ├── app/ ├── screens/ ├── modules/ ├── data/ └── shared/ | ├── constants/ | ├── types/ | ├── utils/ | ├── services/ | ├── stores/ | ├── ui/ | | ├── components/ | | ├── hooks/ | | ├── external.ts | | └── index.ts | └── index.ts   ","version":"Next","tagName":"h2"},{"title":"Data. Работа с данными приложения​","type":1,"pageTitle":"Краткий обзор архитектуры","url":"/guides/docs/arch/overview#data-работа-с-данными-приложения","content":"   Data слой отвечает за работу с данными:  Получения данных из источников (сервер, localStorage…)Агрегация и форматирование данныхКэширование и модификация кэшаРаспространение типов DTO по приложению  Data позволяет:  Защитить приложение от изменений APIОтвязаться от источника данных и метода их получения  Data содержит два сегмента:  Repositories . Facade, предоставляющий данные приложению.Sources. Сервисы, отвечающие за получение данных из разных источников. Sources может быть автосгенерированным  ├── app/ ├── screens/ ├── modules/ ├── data/ | ├── repositories/ | ├── sources/ | └── index.ts └── shared/   ","version":"Next","tagName":"h2"},{"title":"Sources​","type":1,"pageTitle":"Краткий обзор архитектуры","url":"/guides/docs/arch/overview#sources","content":" Sources - сегмент с сервисами без логики, ответственные только за получение данных из различных источников. Источник может быть любой: API, localStorage…  Sources не занимаются форматированием данных, они просто их достают из источника и передают Repository.  ","version":"Next","tagName":"h3"},{"title":"Repositories​","type":1,"pageTitle":"Краткий обзор архитектуры","url":"/guides/docs/arch/overview#repositories","content":" Repositories - это сервисы, используемые в Modules для работы с данными. Данные в Modules запрашиваются только через Repositories.  Repositories используют Sources для получения данных и дальнейшей их агрегации, форматирования, кэширования.  ","version":"Next","tagName":"h3"},{"title":"Разработка через Contract First​","type":1,"pageTitle":"Краткий обзор архитектуры","url":"/guides/docs/arch/overview#разработка-через-contract-first","content":" Архитектурный подход предоставляет удобный инструмент для разработки в случае, когда API еще не реализовано, но уже есть контракты (Contract First).  Contract First подход  ","version":"Next","tagName":"h3"},{"title":"Modules. Ориентированность на бизнес​","type":1,"pageTitle":"Краткий обзор архитектуры","url":"/guides/docs/arch/overview#modules-ориентированность-на-бизнес","content":"   Modules - самый важный слой приложения. Modules должен иметь высокое покрытие тестами.  Данный слой содержит реализацию бизнес требований, которые делают продукт конкурентоспособным. Именно на этот слой должно быть обращено наибольшее внимание при проектировании и разработке.  Для качественной реализации бизнес требований необходимо учитывать особенности предметной области проекта.  В Astral Architecture предметная область разбивается на подобласти (модули), в рамках которых существуют свои термины, сущности и бизнес процессы.  Благодаря модульности проект может масштабироваться: модуль может быть отдан на разработку другой команде или вынесен в независимый микрофронтенд.  Модуль содержит два сегмента:  Features. Фичи, поставляемые модулемDomain. Чистая бизнес-логика, поставляемая модулем  Пример структуры:  ├── app/ ├── screens/ ├── modules/ | └── payment/ | | ├── features/ | | ├── domain/ | | └── index.ts ├── data/ └── shared/   ","version":"Next","tagName":"h2"},{"title":"Features. Фичи приложения​","type":1,"pageTitle":"Краткий обзор архитектуры","url":"/guides/docs/arch/overview#features-фичи-приложения","content":" Каждый модуль предоставляет набор фич, комбинация которых формирует экраны приложения (screens) или другие фичи.  Feature - это готовый для использования компонент, решающий свою задачу.  Благодаря Features, любой член команды (даже не разработчик) может легко и быстро определить, какие возможности и функции предоставляет данное приложение, просто взглянув на названия директорий.    Пример структуры:  ├── app/ ├── screens/ ├── modules/ | └── payment/ | | ├── features/ | | | ├── PaymentSwitch/ | | | ├── CardPayment/ | | | ├── CashPayment/ | | | └── index.ts | | ├── domain/ | | └── index.ts ├── data/ └── shared/   Feature содержит в себе все необходимое для работы:  UI компонент, отвечающий только за отрисовку фичи. В компоненте не реализуется никакая логикаЛогику фичи. Вся логика фичи, включая ui-логику, реализуется вне ui компонентаСтили компонентаДругие UI компоненты, входящие в состав основного компонентаДругие программные сущности необходимые для корректной работы фичи  UI компонент должен быть ответственным только за отображение, количество ui логики в компоненте должно быть сведено к нулю**.**  Вся логика реализуется вне компонента. Логика может быть реализована на любом предпочтительном стэке с использованием:  state managerhook (React стэк)service  Отделение view слоя от логики дает следующие преимущества:  Возможность изменять логику и ui независимоПростота переиспользования логики или ui по необходимостиНезависимость от используемого фреймворка. Фреймворк при определенных обстоятельствах можно заменить, а логику переиспользоватьПростота тестирования. Можно тестировать отдельно логику и uiОднозначность расположения логики. Вся логика всегда находится в одном местеЛогика не “размазывается” по компонентам. Избавляет от сложностей в поддержке кодаПовышение читаемости кодаУпрощение поддержки и доработки приложения  Если необходима логика предметной области, переиспользуемая между фичами или модулями, то она помещается в Domain.  ","version":"Next","tagName":"h3"},{"title":"Domain. Чистая бизнес-логика​","type":1,"pageTitle":"Краткий обзор архитектуры","url":"/guides/docs/arch/overview#domain-чистая-бизнес-логика","content":" Domain содержит :  Чистую логику, реализующую бизнес-требованияЛогику, переиспользуемую между фичами или в других модуляхРаботу с данными, взаимодействие с DataТипы, описывающие особенности предметной областиКонстанты, относящиеся к предметной области  Если логика не связана с предметной областью проекта, то она должна быть вынесена в shared.  Пример структуры:  ├── app/ ├── screens/ ├── modules/ | └── cart/ | | ├── features/ | | └── domain/ | | | ├── services/ | | | ├── stores/ | | | | ├── CartStore/ | | | | └── index.ts | | | ├── utils/ | | | ├── types/ | | | ├── constants/ | | | └── index.ts | | └── index.ts ├── data/ └── shared/   ","version":"Next","tagName":"h3"},{"title":"Screens. Место, где собираются фичи приложения​","type":1,"pageTitle":"Краткий обзор архитектуры","url":"/guides/docs/arch/overview#screens-место-где-собираются-фичи-приложения","content":"   Screens - это экраны приложения.  Скрины собираются из features разных модулей. Здесь же происходит интеграция features.  Screens используется в роутинге Application для привязки к рутам приложения и взаимодействия с окружением роутинга (например, query params).  Пример структуры:  ├── app/ ├── screens/ | ├── Feedback/ | ├── NoAccess/ | ├── NotFound/ | ├── PopularGoods/ | ├── NewGoods/ | | ├── NewGoods.tsx | | ├── store/ | | └── index.ts | └── index.ts ├── modules/ ├── data/ └── shared/   ","version":"Next","tagName":"h2"},{"title":"Application. Единственный слой, зависимый от специфики окружения и фреймворка​","type":1,"pageTitle":"Краткий обзор архитектуры","url":"/guides/docs/arch/overview#application-единственный-слой-зависимый-от-специфики-окружения-и-фреймворка","content":"   Application слой является единственным слоем, который:  Зависит от окружения Особенности сборщикаРабота с env Зависит от специфичности используемого фреймворкаЗависит от низкоуровневых реализаций (используемых библиотек)  Application слой содержит:  Роутинг приложенияИнициализацию/настройку приложения и всех сервисов  Пример структуры для React:  ├── app/ | ├── Routing/ | └── App.tsx ├── screens/ ├── modules/ ├── data/ └── shared/   Пример структуры для Nextjs:  ├── pages/ # pages является application слоем (Nextjs специфичность) | ├── index.tsx | ├── _app.tsx ├── screens/ ├── modules/ ├── data/ └── shared/   ","version":"Next","tagName":"h2"},{"title":"Тестирование​","type":1,"pageTitle":"Краткий обзор архитектуры","url":"/guides/docs/arch/overview#тестирование","content":" Тестирование в Astral Architecture Guide являются важной частью проектируемой системы.  Тесты должны получать такое же внимание и фокус на качестве, как и другой значимый код в проекте.  В Astral Architecture Guide описаны принципы тестирования, позволяющие реализовывать важные атрибуты тестирования:  Защита от баговУстойчивость к рефакторингу - низкий уровень хрупкостиСкорость выполненияПростота поддержки ","version":"Next","tagName":"h2"},{"title":"Работа с env в архитектуре","type":0,"sectionRef":"#","url":"/guides/docs/env/arch","content":"","keywords":"","version":"Next"},{"title":"ConfigService​","type":1,"pageTitle":"Работа с env в архитектуре","url":"/guides/docs/env/arch#configservice","content":" Слои приложения, отличные от application, должны получать данные из env через ConfigService.  Подробнее о ConfigService читайте в документации. ","version":"Next","tagName":"h2"},{"title":"Intro","type":0,"sectionRef":"#","url":"/guides/docs/env/intro","content":"Intro Раздел содержит: Как работать с env в рамках единой архитектурыКак генерировать и загружать env в CSR (Client Side Rendering)","keywords":"","version":"Next"},{"title":"Безопасность. Использование PUBLIC и PRIVATE env","type":0,"sectionRef":"#","url":"/guides/docs/env/safety","content":"","keywords":"","version":"Next"},{"title":"Мотивация​","type":1,"pageTitle":"Безопасность. Использование PUBLIC и PRIVATE env","url":"/guides/docs/env/safety#мотивация","content":" Если все env переменные сделать доступные в браузере, то злоумышленники могут найти уязвимости системы потому, что env хранит информацию о сервере, на котором запускает билд или само приложение.  Именно по этой причине Nextjs и Vite требуют для env переменных префиксы: NEXT_PUBLIC | NEXT_PRIVATE, VITE_.  ","version":"Next","tagName":"h2"},{"title":"CSR​","type":1,"pageTitle":"Безопасность. Использование PUBLIC и PRIVATE env","url":"/guides/docs/env/safety#csr","content":" Если приложение собирается через webpack, то достаточно просто следовать указанным ранее соглашениям по именованию.  Если приложение собирается через vite, то необходимо использовать envPrefix для кастомизации префикса. ","version":"Next","tagName":"h2"},{"title":"Intro","type":0,"sectionRef":"#","url":"/guides/docs/intro","content":"Intro Архитектура и стандартные фичи, описанные в документации, должны быть использованы при проектировании frontend в Астрал-Софт.","keywords":"","version":"Next"},{"title":"Issues","type":0,"sectionRef":"#","url":"/guides/docs/issues","content":"Issues Предложения по изменению документации или добавлению новых правил принимают либо на доске Frontend.Shared, либо через PR на Github.","keywords":"","version":"Next"},{"title":"Nextjs. SSR и SSG","type":0,"sectionRef":"#","url":"/guides/docs/env/ssr","content":"Nextjs. SSR и SSG Если на проекте используется Nextjs, то необходимо использовать тот механизм работы с env, который предоставляет фреймворк. При SSR и SSG env нужны при билде.","keywords":"","version":"Next"},{"title":"Вдохновлено ABAC и XAML","type":0,"sectionRef":"#","url":"/guides/docs/permissions/core","content":"","keywords":"","version":"Next"},{"title":"На клиенте нужен ABAC, даже если на бэкенде RBAC​","type":1,"pageTitle":"Вдохновлено ABAC и XAML","url":"/guides/docs/permissions/core#на-клиенте-нужен-abac-даже-если-на-бэкенде-rbac","content":" В этой статье вы можете прочитать чем концептуально отличаются ABAC (Attribute-Based Access Control) и RBAC (Role Based Access Control).  На Frontend'е нужна такая система доступов, которая однозначно будет указывать на предмет блокировок доступов в контексте пользовательского интерфейса. RBAC и даже ABAC, имплементированный на стороне API не будет зависеть от UI, который привносит свою дополнительную специфичность при расчете доступов.  В связи с этим, на клиенте необходимо перманентно использовать ABAC, доступы которого будут напрямую связаны со специфичностью UI.  ","version":"Next","tagName":"h2"},{"title":"Пример с RBAC на бэкенде​","type":1,"pageTitle":"Вдохновлено ABAC и XAML","url":"/guides/docs/permissions/core#пример-с-rbac-на-бэкенде","content":" Предметная область  ЭДО  Роли  PaymentAccountFreeAccount  Бизнес требование  Кнопка &quot;Создать документ&quot; доступна для пользователя с платным аккаунтом и если у него есть созданная организация.  Проблема  Из требования видно, что для вычисления доступа не хватает только одного знания о роле пользователя (роль PaymentAccount), необходимо дополнительно учитывать есть у пользователя организация.  Неверное решение  Добавить к кнопке дополнительный if на проверку организации. Это приведет к &quot;размазыванию&quot; логики доступов по приложению и последующую потерю контроля.  Правильное решение  Использование ABAC с permission docActions, который внутри будет проверять роль пользователя и наличие организации.docActions будет использоваться в необходимых частях приложения для проверки доступа к действиям на документом.  ","version":"Next","tagName":"h3"},{"title":"Пример с ABAC на бэкенде​","type":1,"pageTitle":"Вдохновлено ABAC и XAML","url":"/guides/docs/permissions/core#пример-с-abac-на-бэкенде","content":" Предметная область  ЭДО  Permissions с API  docActions  Бизнес требование  Кнопка &quot;Создать документ&quot; доступна для пользователя с платным аккаунтом и если он прошел двух факторную аутентификацию.  Проблема  В docActions на бэкенде проверяется оплачен ли аккаунт пользователя, но проверку на 2FA можно провести только в runtime при нажатии на саму кнопку.  Решение  Добавить в едином клиентском сервисе доступов дополнительную логику для docActions, которая будет проверять 2FA. ","version":"Next","tagName":"h3"},{"title":"CSR + Nginx. Динамические env","type":0,"sectionRef":"#","url":"/guides/docs/env/csr","content":"","keywords":"","version":"Next"},{"title":"Пример​","type":1,"pageTitle":"CSR + Nginx. Динамические env","url":"/guides/docs/env/csr#пример","content":" Пример реализован в vite-boilerplate.  ","version":"Next","tagName":"h2"},{"title":"Проблема получения env в build time​","type":1,"pageTitle":"CSR + Nginx. Динамические env","url":"/guides/docs/env/csr#проблема-получения-env-в-build-time","content":" Получение env в build time - это классический подход.  Работает следующим образом:  Сборщик при запуске получаетЛибо помещает полученные env в import.meta.env (vite), либо делает replace process.env переменных на их значения непосредственно в js коде (webpack)Переменные доступны в браузере при выполнении js  Проблемы:  Для изменения значений env необходимо заново пересобирать приложениеЕсли в приложении есть поддержка white label, то для каждого бренда необходимо собирать отдельный docker image. Это сильно увеличивает время сборки приложения и количество ресурсов, необходимое для поддержки и развертывания  Для решения описанных проблем необходимо делать inject env в html при запуске docker контейнера.  ","version":"Next","tagName":"h2"},{"title":"Генерация index.html и inject env​","type":1,"pageTitle":"CSR + Nginx. Динамические env","url":"/guides/docs/env/csr#генерация-indexhtml-и-inject-env","content":" Для того чтобы при изменении env переменных не приходилось заново делать сборку, необходимо при запуске docker контейнера генерировать index.html и инжектировать в html env переменные.  ","version":"Next","tagName":"h2"},{"title":"Генерация index.html из index.template.html​","type":1,"pageTitle":"CSR + Nginx. Динамические env","url":"/guides/docs/env/csr#генерация-indexhtml-из-indextemplatehtml","content":" В репозитории должен находиться только index.template.html - это шаблон html, на основе которого будет построен index.html.  index.html должен быть добавлен в .gitignore.  Содержимое index.template.html​  Пример index.template.html  index.template.html содержит всю необходимую для приложения разметку и &lt;script&gt; в &lt;head&gt;:  &lt;script&gt; &lt;!-- При запуске dev команды или запуске docker контейнера в __ENV__ подставятся значения из окружения --&gt; window.__ENV__={}; &lt;/script&gt;   Зачем нужен index.template.html и почему index.html в .gitignore?​  При запуске dev-server должно происходить inject env переменных в index.html, если файл не будет в .gitignore, то в репозиторий могут случайно попасть изменения, которых разработчик не делал.  Для генерации и inject env используются bash скрипты.​  Bash используется по причине того, что для CSR в компании используется Nginx. Это означает, что в итоговом docker контейнере нет nodejs, а если добавить в образ nodejs, то он вырастет в разы по объему, что повлияет на скорость сборок и оптимизацию хранилища.  ","version":"Next","tagName":"h3"},{"title":"Dev Mode​","type":1,"pageTitle":"CSR + Nginx. Динамические env","url":"/guides/docs/env/csr#dev-mode","content":" ","version":"Next","tagName":"h2"},{"title":"Генерация index.html. generateEnv.dev.sh скрипт​","type":1,"pageTitle":"CSR + Nginx. Динамические env","url":"/guides/docs/env/csr#генерация-indexhtml-generateenvdevsh-скрипт","content":" Пример generateEnv.dev.sh  В режиме разработки необходимо, чтобы перед каждым запуском dev-server выполнялся bash скрипт, который:  Парсит все переменные из файла .env.local (или .env.dev) с префиксами PUBLIC_Создает в директории для раздачи статики index.html с копией содержимого из index.template.html. Для vite директория для раздачи статики - это корень приложения. Для webpack - public директорияЗаменяет в index.html window.__ENV__={} на:  window.__ENV__={&quot;PUBLIC_API_URL&quot;:&quot;https://astral.ru&quot;};   ","version":"Next","tagName":"h3"},{"title":"Prod Mode​","type":1,"pageTitle":"CSR + Nginx. Динамические env","url":"/guides/docs/env/csr#prod-mode","content":" ","version":"Next","tagName":"h2"},{"title":"Генерация index.html​","type":1,"pageTitle":"CSR + Nginx. Динамические env","url":"/guides/docs/env/csr#генерация-indexhtml","content":" Dockerfile​  При запуске docker контейнера необходимо запускать bash скрипт, который сгенерирует index.html файл и инжектирует в него env. Для этого в Dockerfile необходимо добавить команду выполнения скрипта при запуске контейнера:  FROM node:22-alpine AS build WORKDIR /usr/src/app COPY package.json package-lock.json* ./ COPY . . RUN npm i --production RUN npm run build FROM fholzer/nginx-brotli:v1.19.1 COPY .nginx/nginx.conf.template /etc/nginx/nginx.conf.template COPY --from=build /usr/src/app/dist /usr/share/nginx/html # Запускаем контейнер при помощи exec в shell оболочке, чтобы иметь доступ к env ENTRYPOINT [&quot;sh&quot;, &quot;/usr/share/nginx/html/scripts/startup.prod.sh&quot;]   Скрипт startup.prod.sh​  Пример startup.prod.sh  Скрипт startup.prod.sh выполняет следующие действия:  Достает из текущего окружения все env переменные с префиксом PUBLIC_Создает index.html с копией содержимого из index.template.htmlЗаменяет в index.html window.__ENV__={} на:  window.__ENV__={&quot;PUBLIC_API_URL&quot;:&quot;https://astral.ru&quot;};   Подменяет переменные для nginx на их значения. Читай об этом подробнее здесьЗапускает nginx  ","version":"Next","tagName":"h3"},{"title":"Подстановка переменных в nginx​","type":1,"pageTitle":"CSR + Nginx. Динамические env","url":"/guides/docs/env/csr#подстановка-переменных-в-nginx","content":" В зависимости от env в проекте может изменяться nginx.conf.  Для того чтобы nginx.conf менялся при запуске необходимо:  Создать в проекте файл nginx.conf.template. Из него будет генерироваться уже настоящий nginx.conf.Заменить динамические участки конфига на ${PUBLIC_WS_URL}. Пример:  http { ... server { listen 80; listen [::]:80; ... add_header Content-Security-Policy connect-src 'self' ${PUBLIC_WS_URL}; ... } }   Добавить в startup.prod.sh следующий код с переменными, которые необходимо подменить:  # Необходимо экспортировать, тк envsubst является разветвленным процессом и не знает неэкспортируемых переменных export PUBLIC_WS_URL # Подмена указанных переменных в nginx.conf.template и копирование всего файла в nginx.conf envsubst &quot;${PUBLIC_WS_URL}&quot; &lt; /etc/nginx/nginx.conf.template &gt; /etc/nginx/nginx.conf   При запуске startup.prod.sh подменит в nginx.conf.template все переменные на их значения и создаст nginx.conf, который и будет использовать для запуска nginx  ","version":"Next","tagName":"h3"},{"title":"Использование env из сгенерированного файла​","type":1,"pageTitle":"CSR + Nginx. Динамические env","url":"/guides/docs/env/csr#использование-env-из-сгенерированного-файла","content":" Для использования переменных необходимо определить тип для window.__ENV__ в global.d.ts:  interface Window { __ENV__: { PUBLIC_API_URL: string; PUBLIC_SENTRY_DSN: string; PUBLIC_SENTRY_ENV: string; PUBLIC_RELEASE_TAG: string; }; }   В браузере доступ к env переменным осуществляется через window.__ENV__ в application слое приложения:  configService.init({ apiUrl: window.__ENV__.PUBLIC_API_URL, monitoringDsn: window.__ENV__.PUBLIC_SENTRY_DSN, monitoringStand: window.__ENV__.PUBLIC_SENTRY_ENV, monitoringRelease: window.__ENV__.PUBLIC_RELEASE_TAG, });   ","version":"Next","tagName":"h2"},{"title":"Преимущества inject env в index.html​","type":1,"pageTitle":"CSR + Nginx. Динамические env","url":"/guides/docs/env/csr#преимущества-inject-env-в-indexhtml","content":" Inject env позволяет:  Получать env в браузере синхронно. Нет необходимости делать обработку асинхронного получения данных. Код приложения гарантированно получает все env на этапе выполненияСнизить к 0 затраты на загрузку динамических env ","version":"Next","tagName":"h2"},{"title":"2FA (Two-factor Auth)","type":0,"sectionRef":"#","url":"/guides/docs/permissions/2fa","content":"","keywords":"","version":"Next"},{"title":"Пример​","type":1,"pageTitle":"2FA (Two-factor Auth)","url":"/guides/docs/permissions/2fa#пример","content":" Требования  Создание документа доступно только администратору с активной 2FA.  Реализация  modules/permissions/domain/stores/PermissionsStore/policies/AdministrationPolicyStore  export class AdministrationPolicyStore { private readonly policy: Policy; constructor( private readonly policyManager: PolicyManagerStore, private readonly userRepo: UserRepository, private readonly twoFA: TwoFAService, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policy = this.policyManager.createPolicy({ name: 'administration', prepareData: async (): Promise&lt;void&gt; =&gt; { await Promise.all([this.userRepo.getRolesQuery().async()]); }, }); } /** * Доступ к действиям администратора */ public get administrationActions() { return this.policy.createPermission((allow, deny) =&gt; { // Если twoFA не пройдена, то отказываем в доступе с причиной, которая будет обработана в features // Также, по необходимости, можно вызвать логику запроса от пользователя прохождения 2FA if (!twoFA.isPassed) { return deny(PermissionDenialReason.TwoFA); } if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } deny(PermissionDenialReason.NoAdmin); }); } }   modules/layout/features/MainLayout/Sidebar/UIStore  export class UIStore { constructor( private readonly permissions: PermissionsStore, private readonly twoFA: TwoFAService, private readonly notifyService: Notify, private readonly router: Router, ) { makeAutoObservable(this, {}, { autoBind: true }); } public openDocCreation = () =&gt; { const permission = this.permissions.administration.administrationActions; if (permission.isAllowed) { this.router.push(APP_ROUTES.createDoc.getRedirectPath()); return; } if (permission.hasReason(PermissionDenialReason.NoAdmin)) { this.notifyService.error( 'Доступно только администратору' ); return; } if (permission.hasReason(PermissionDenialReason.TwoFA)) { // Здесь можно, например, реализовать открытие модалки для 2FA this.notifyService.error( 'Нужно пройти 2FA', ); return; } this.notifyService.error( 'Добавить документ на полку нельзя. Попробуйте сменить аккаунт', ); }; }  ","version":"Next","tagName":"h2"},{"title":"Пример реализации паттерна","type":0,"sectionRef":"#","url":"/guides/docs/permissions/example","content":"","keywords":"","version":"Next"},{"title":"Permissions Module​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#permissions-module","content":" https://github.com/kaluga-astral/vite-boilerplate/tree/main/modules/permissions  ","version":"Next","tagName":"h2"},{"title":"Policies​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#policies","content":" https://github.com/kaluga-astral/vite-boilerplate/tree/main/modules/permissions/domain/stores/PermissionsStore/policies  ","version":"Next","tagName":"h2"},{"title":"Reasons​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#reasons","content":" https://github.com/kaluga-astral/vite-boilerplate/blob/main/modules/permissions/domain/enums.ts  ","version":"Next","tagName":"h2"},{"title":"Rules​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#rules","content":" https://github.com/kaluga-astral/vite-boilerplate/tree/main/modules/permissions/domain/stores/PermissionsStore/rules  ","version":"Next","tagName":"h2"},{"title":"Использование rules​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#использование-rules","content":" https://github.com/kaluga-astral/vite-boilerplate/blob/main/modules/permissions/domain/stores/PermissionsStore/policies/PaymentPolicyStore/PaymentPolicyStore.ts#L33  ","version":"Next","tagName":"h3"},{"title":"Использование permissions в UIStore​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#использование-permissions-в-uistore","content":" https://github.com/kaluga-astral/vite-boilerplate/blob/main/modules/books/features/BookList/UIStore/UIStore.ts#L76  ","version":"Next","tagName":"h2"},{"title":"Подготовка данных​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#подготовка-данных","content":" https://github.com/kaluga-astral/vite-boilerplate/blob/main/application/app.tsx#L44  ","version":"Next","tagName":"h2"},{"title":"Route Guards​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#route-guards","content":" https://github.com/kaluga-astral/vite-boilerplate/tree/main/modules/permissions/features/routeGuards  ","version":"Next","tagName":"h2"},{"title":"Использование Route Guards​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#использование-route-guards","content":" admin pagebook reading page ","version":"Next","tagName":"h3"},{"title":"Intro","type":0,"sectionRef":"#","url":"/guides/docs/permissions/intro","content":"","keywords":"","version":"Next"},{"title":"Необходимо применять когда​","type":1,"pageTitle":"Intro","url":"/guides/docs/permissions/intro#необходимо-применять-когда","content":" В системе уже реализована какая-либо система доступов без централизованного управления на клиентеAPI предоставляет сведения о ролях. Паттерн работает в связке с ролевой модельюAPI предоставляет сведения о доступах. Паттерн расширяет на клиенте доступы, полученные из APIНа клиенте необходимо по условию (любому) закрывать доступ к части функционалаБизнес-требования описывают доступность функционала при определенных условиях (роль, сведения об оплате...)  ","version":"Next","tagName":"h2"},{"title":"Применение паттерна позволяет​","type":1,"pageTitle":"Intro","url":"/guides/docs/permissions/intro#применение-паттерна-позволяет","content":" Уменьшить затраты на разработку системы доступовИметь единую реализацию системы доступов во всех приложениях компанииЦентрализованно развивать паттернИзбежать повторения одних и тех же ошибок реализации в разных приложениях  ","version":"Next","tagName":"h2"},{"title":"Паттерн предоставляет​","type":1,"pageTitle":"Intro","url":"/guides/docs/permissions/intro#паттерн-предоставляет","content":" Удобный и поддерживаемый способ формирования доступов на клиентеСистему причин отказа в доступе. Позволяет улучшить UX и DX при работе с доступами: пользователь и разработчик получают конкретную причину отказа в доступеПодход загрузки данных для формирования доступовЗакрытие рутов приложения (RouteGuards)Взаимодействие с другими сервисами. Например, FeatureToggle  ","version":"Next","tagName":"h2"},{"title":"Готовый пакет @astral/permissions​","type":1,"pageTitle":"Intro","url":"/guides/docs/permissions/intro#готовый-пакет-astralpermissions","content":" Для более простой поддержки паттерна был реализован пакет @astral/permissions, который используется в примерах данной документации. ","version":"Next","tagName":"h2"},{"title":"Data","type":0,"sectionRef":"#","url":"/guides/docs/arch/data","content":"","keywords":"","version":"Next"},{"title":"Основная концепция​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#основная-концепция","content":"   Data слой отвечает за работу с данными:  Получения данных из источников (сервер, localStorage…)Агрегация и форматирование данныхКэширование и модификация кэшаХранение и распространение DTO по приложению  Data позволяет:  Защитить приложение от изменений APIОтвязаться от источника данных и методе их получения  Data содержит два сегмента:  Repositories . Facade, предоставляющий данные приложению.Sources. Сервисы, отвечающие за получение данных из разных источников. Sources может быть автосгенерированным  ├── app/ ├── screens/ ├── modules/ ├── data/ | ├── repositories/ | ├── sources/ | └── index.ts └── shared/   ","version":"Next","tagName":"h2"},{"title":"Защита от изменений API​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#защита-от-изменений-api","content":" Data позволяют защитить приложение от изменений API.  Sources напрямую зависят от API и источника, они недоступны для остального приложения.  Приложение зависит только от Repositories, поэтому при нежелательном изменении интерфейса данных на API, изменения коснуться только Repositories , остальная часть приложения останется неизменной.    Пример  Мы получаем с сервера данные о тарифе. tariffNetworkSources отвечает за получение данных из конкретного источника по REST.  TariffRepository в свою очередь использует tariffNetworkSources для получения данных и их форматирования для приложения.  В какой-то момент API изменило формат данных для тарифов. Если мы не хотим вносить правки в Modules, которые потребляют данные, то мы можем на уровне TariffRepository сделать правки, по приведению нового интерфейса данных тарифов к тому, что ожидает наше приложение.  В итоге: правки были внесены только в TariffRepository , остальная система затронута не была.  ","version":"Next","tagName":"h2"},{"title":"Независимость приложения от источника данных​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#независимость-приложения-от-источника-данных","content":" Благодаря Data приложение не зависит от источника данных. По необходимости источник данных и метод получения данных может быть изменен.  Repositories используют Sources для получения данных. Sources при этом зависит от конкретного метода получения данных (REST, GQL, WS…). Приложение в свою очередь взаимодействует только с Repositories и не знает откуда и как данные были получены.  Пример  tariffSourcesNetwork может получать данные по REST, при этом requestSourcesNetwork может получать данные по GQL.  Нам необходимо получить данные о заявке и выбранной в ней тарифе. RequestRepository предоставит нашему приложению метод getRequestWithTariff , который соберет данные из разных источников и отдаст их приложению.  Итог: приложение не знает каким способом и от куда были запрошены данные.  ","version":"Next","tagName":"h2"},{"title":"Sources​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#sources","content":" Sources - это сервисы, ответственные за получение данных. Sources зависят от конкретного источника данных.  Sources могут быть сгенерированы по OpenAPI или другим доступным способом.  Sources не содержат никакой логики, они просто ходят за данными в нужный источник.  Пример получения данных по REST  import { apiHttpClient } from '@astral/shared'; import { TariffNetworkSourcesDTO } from './dto'; export const tariffsNetworkSources = { getTariffs: () =&gt; apiHttpClient.get&lt;void, TariffNetworkSourcesDTO.TariffList&gt;('/tariffs'), };   Sources содержат:  Сервис получения данныхDTO  Пример структуры:  ├── app/ ├── screens/ ├── modules/ ├── data/ | ├── repositories/ | ├── sources/ | | ├── tariffsNetworkSources/ | | | ├── tariffsNetworkSources.ts | | | ├── dto.ts | | | └── index.ts | | └── index.ts | └── index.ts └── shared/   Sources - это приватные сервисы слоя Data. Sources недоступны в других слоях. Все взаимодействие с данными в приложении происходит через Repositories.  ","version":"Next","tagName":"h2"},{"title":"Разные источники данных​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#разные-источники-данных","content":" Sources могут получать данные из разных источников, разными способами:  RESTGraphQLLocalStorageIndexDBCookieФайловая система…  ","version":"Next","tagName":"h3"},{"title":"DTO​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#dto","content":" Sources содержат типы данных, которые надо отправить на сервер и типы данных, которые приходят в ответ.  Все типы DTO находятся в файле dto.ts.  ├── app/ ├── screens/ ├── modules/ ├── data/ | ├── repositories/ | ├── sources/ | | ├── tariffsNetworkSources/ | | | ├── tariffsNetworkSources.ts | | | ├── dto.ts | | | └── index.ts | | └── index.ts | └── index.ts └── shared/   ","version":"Next","tagName":"h3"},{"title":"Repositories​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#repositories","content":" Repositories - это фасады, используемые в приложении для работы с данными.  Repositories:  Используют sources для получения данных из разных источниковФорматируют данные для приложенияАгрегируют данные из разных источниковКэшируют данные. Позволяют работать с данными кэша (модифицировать, инвалидировать…)  Repositories содержит сервисы для работы с данными.  Пример структуры:  ├── app/ ├── screens/ ├── modules/ ├── data/ | ├── repositories/ | | ├── UserRepository/ | | | ├── UserRepository.ts | | | ├── UserRepository.test.ts | | | ├── dto.ts | | | ├── enums.ts | | | └── index.ts | | ├── enums.ts | | ├── types.ts | | └── index.ts | ├── sources/ | └── index.ts └── shared/   Пример Repository:  ","version":"Next","tagName":"h2"},{"title":"Разбиение на Repositories​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#разбиение-на-repositories","content":" Каждый Repository ответственен за работу с конкретным типом данных.  Пример  В предметной области онлайн-магазина нам необходимо получать данные о:  ПользователеТоварахАкциях  Для каждого типа данных должны быть созданы свои Repositories:  ├── app/ ├── screens/ ├── modules/ ├── data/ | ├── repositories/ | | ├── UserRepository/ | | ├── GoodsRepository/ | | ├── PromotionsRepository/ | | └── index.ts | ├── sources/ | └── index.ts └── shared/   ","version":"Next","tagName":"h3"},{"title":"Агрегация и форматирование данных​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#агрегация-и-форматирование-данных","content":" Repositories для получения данных используют Sources.  Один Repository может взаимодействовать с несколькими sources.  Также Repository могут взаимодействовать друг с другом для получения данных.  Пример  Мы работает в предметной области онлайн-магазина.  Нам в Promotion модуле необходимо отобразить данные об акции:  Название, описание акцииСписок товаров, подходящих под акцию Краткая информация о товаре: название, стоимость, изображение  promotionNetworkSources позволит получить данные об акции, но она будет содержать внутри себя только список ID товаров.  GoodsRepository предоставляет метод для получения и кэширования данных по товарам. Использует для получения данных goodsNetworkSources.  PromotionRepository предоставит метод, который получит данные из promotionNetworkSources и GoodsRepository , затем склеит их и отформатирует так, как удобно нашему приложению.    ","version":"Next","tagName":"h3"},{"title":"Работа с кэшом​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#работа-с-кэшом","content":" На уровне Repositories должна происходить работа с кэшом.  Repositories должен скрывать реализацию кэша и предоставлять приложению абстрактные методы по работе с данными.  Пример UserRepository с использованием @astral/mobx-query для кэширования:  import { CacheService } from '@astral/shared'; import { UserNetworkSources } from '../../sources'; class UserRepository { private userInfoCacheID = 'user-info'; constructor( private readonly userNetworkSources: UserNetworkSources, private readonly cacheService: CacheService, ) { this.userNetworkSources = userNetworkSources; this.cacheService = cacheService; } public getUserInfo = () =&gt; cacheService.createQuery( [this.userInfoCacheID], this.userNetworkSources.getPersonInfo, ); public invalidateUserInfo = () =&gt; { this.cacheService.invalidate([this.userInfoCacheID]); }; }   ","version":"Next","tagName":"h3"},{"title":"DTO​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#dto-1","content":" Repositories содержат DTO, используемые в приложении.  ├── app/ ├── screens/ ├── modules/ ├── data/ | ├── repositories/ | | ├── UserRepository/ | | | ├── UserRepository.ts | | | ├── UserRepository.test.ts | | | ├── dto.ts | | | ├── enums.ts | | | └── index.ts | | └── index.ts | ├── sources/ | └── index.ts └── shared/   Repository использует для формирования своих DTO, типы из sources.  Возможен сценарий простого реэкспорта DTO из sources, это допустимо и необходимо для того, чтобы в любой момент можно было изменить формат данных в Repository.  data/repositories/UserRepository/dto.ts  import { UserNetworkSourcesDTO, TariffNetworkSourcesDTO, } from '../../sources'; export namespace UserRepositoryDTO { export type User = UserNetworkSourcesDTO.User &amp; UserNetworkSourcesDTO.Permissions; export type EditUserInfoInput = UserNetworkSourcesDTO.EditUserInfoInput; export type TariffList = TariffNetworkSourcesDTO.TariffList; }   Enums​  DTO Repositories могут содержать enums. Enums должны быть созданы или реэкспортированы через enums.ts в конкретном Repository .  data/repositories/UserRepository/enums.ts  export { UserPermission } from '../sources'; export enum UserStatus { active, inactive, }   ","version":"Next","tagName":"h3"},{"title":"Проксирующие запросы​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#проксирующие-запросы","content":" В Repositories достаточно часто могут использоваться проксирующие запросы на sources:  dto.ts  import { TariffNetworkSourcesDTO } from '../../sources'; export namespace TariffRepositoryDTO { export type Tariff = TariffNetworkSourcesDTO.Tariff; export type TariffList = TariffNetworkSourcesDTO.TariffList; }   TariffRepository.ts  export class TariffRepository { constructor(private readonly tariffNetworkSources: TariffsNetworkSources) { this.tariffNetworkSources = tariffNetworkSources; } public getTariffs = async () =&gt; this.tariffNetworkSources.getTariffs(); }   Данное явление является нормой потому, что позволяет нашему приложению не зависеть от sources и API.  По необходимости, мы можем изменить источник данных или формат данных на уровне Repository.  ","version":"Next","tagName":"h3"},{"title":"DI для Repositories​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#di-для-repositories","content":" Все зависимости Repository должны быть инвертированы. Рекомендуется использовать простой DI без IoC.  import { CacheService } from '@astral/shared'; import { UserNetworkSources } from '../../sources'; class UserRepository { private userInfoCacheID = 'user-info'; constructor( private readonly userNetworkSources: UserNetworkSources, private readonly cacheService: CacheService, ) { this.userNetworkSources = userNetworkSources; this.cacheService = cacheService; } public getUserInfo = () =&gt; cacheService.createQuery( [this.userInfoCacheID], this.userNetworkSources.getPersonInfo, ); public invalidateUserInfo = () =&gt; { this.cacheService.invalidate([this.userInfoCacheID]); }; }   Repository должен контролировать зависимости через конструктор. В конструкторе описываются все внешние зависимости.  Плюсы использования DI:  Контроль зависимостей. Сразу видно от чего зависит RepositoryПростота тестирования. Зависимость можно подменить на моковую для тестаНизкое зацепление. Repositories зависят от абстрактный интерфейсов, а не от конкретных реализаций    ","version":"Next","tagName":"h3"},{"title":"Переиспользование enums и types​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#переиспользование-enums-и-types","content":" Между Repositories и Sources можно переиспользовать enums и types:  Переиспользуемые типы, enums | Astral.Frontend Style Guide    ","version":"Next","tagName":"h2"},{"title":"Style Guide Data слоя​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#style-guide-data-слоя","content":" Data | Astral.Frontend Style Guide    ","version":"Next","tagName":"h2"},{"title":"Тестирование​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#тестирование","content":" ","version":"Next","tagName":"h2"},{"title":"Покрываются тестами только Repositories​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#покрываются-тестами-только-repositories","content":" Так как Sources - это приватные сервисы data слоя, не содержащие логики, тестировать их нет необходимости.  Тестировать необходимо только Repositories.  ","version":"Next","tagName":"h3"},{"title":"Правила реализации тестов​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#правила-реализации-тестов","content":" При реализации тестов Repositories необходимо руководствоваться едиными правилами:  Astral.Frontend Unit Testing Guide  ","version":"Next","tagName":"h3"},{"title":"Расположение тестов​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#расположение-тестов","content":" Расположение тестов  ","version":"Next","tagName":"h3"},{"title":"Faker для Sources​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#faker-для-sources","content":" Подробнее о faker читайте здесь:  Фейковые данные для тестов  Рядом с Sources должен находит его faker, который позволит генерировать данные для стабов:  ├── app/ ├── screens/ ├── modules/ ├── data/ | ├── repositories/ | ├── sources/ | | ├── CartNetworkSources/ | | | ├── CartNetworkSources.ts | | | ├── dto.ts | | | ├── faker.ts | | | └── index.ts | | └── index.ts | └── index.ts └── shared/   Пример faker:  export const cartNetworkSourcesFaker = { makeGoodsList(length: number = 10): CartNetworkSourcesDTO.GoodsList { return { data: Array.from({ length }).map(() =&gt; this.makeGoodsItem()), }; }, makeGoodsItem( data?: Partial&lt;CartNetworkSourcesDTO.GoodsItem&gt;, ): CartNetworkSourcesDTO.CartGoodsItemDTO { return { name: faker.commerce.productName(), id: faker.string.uuid(), price: faker.number.int(100000), count: faker.number.int(5), ...data, }; }, };   ","version":"Next","tagName":"h3"},{"title":"Подмена Sources при тестировании Repositories​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#подмена-sources-при-тестировании-repositories","content":" Для тестирования Repositories все Sources необходимо подменять стабами.  При этом для генерации данных стабов Sources используются соответствующие faker.  Пример:  class BookRepository { constructor( private readonly bookNetworkSources: BookNetworkSources, private readonly cache: CacheService, ) {} public getGenreByIDQuery = (id: string) =&gt; this.cache.createQuery( ['genre', id], (): Promise&lt;BookRepositoryDTO.Genre&gt; =&gt; this.bookNetworkSources.getGenreByID(id).then(({ data }) =&gt; data), ); public getBookByNameQuery = (name: string) =&gt; this.cache.createQuery&lt;BookRepositoryDTO.BookByName, ApiDataError&gt;( ['book-by-name', name], async () =&gt; { const { data } = await this.bookNetworkSources.getBookByName({ name, }); const { genreID, ...book } = data; const genre = await this.getGenreByIDQuery(genreID).async(); return { ...book, genre }; }, ); }   describe('BookRepository', () =&gt; { it('Запрос книги по автору формирует подробную информацию об авторе', async () =&gt; { const fakeGenre = bookNetworkSourcesFaker.makeGenre(); const fakeBook = bookNetworkSourcesFaker.makeBookByName(); const bookSourcesMock = mock&lt;BookNetworkSources&gt;({ getBookByName: async () =&gt; makeFakeSourceRes(fakeBook), getGenreByID: async () =&gt; makeFakeSourceRes(fakeGenre), }); const sut = new BookRepository(bookSourcesMock, createCacheService()); const bookByNameQuery = sut.getBookByNameQuery(fakeBook.name); const { genre } = await bookByNameQuery.async(); expect(genre).toEqual(fakeGenre); }); });   ","version":"Next","tagName":"h3"},{"title":"Тестирование публичных методов Repository​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#тестирование-публичных-методов-repository","content":" Тестировать в Repository необходимо только публичные методы, содержащие хоть сколько-нибудь значимую логику.  В примере ниже тестировать необходимо только метод getBookByNameQuery потому, что остальные методы содержат примитивную логику, тестирование которой не повысит надежность системы.  class BookRepository { constructor( private readonly bookNetworkSources: BookNetworkSources, private readonly cache: CacheService, ) {} public getGenreByIDQuery = (id: string) =&gt; this.cache.createQuery&lt;BookRepositoryDTO.Genre&gt;( ['genre', id], () =&gt; this.bookNetworkSources.getGenreByID(id).then(({ data }) =&gt; data), ); public getGenreListQuery = () =&gt; this.cache.createQuery&lt;BookRepositoryDTO.GenreList&gt;( ['genre-list'], () =&gt; this.bookNetworkSources.getGenreList().then(({ data }) =&gt; data), ); public getBookByNameQuery = (name: string) =&gt; this.cache.createQuery&lt;BookRepositoryDTO.BookByName, ApiDataError&gt;( ['book-by-name', name], async () =&gt; { const { data } = await this.bookNetworkSources.getBookByName({ name, }); const { genreID, ...book } = data; const genre = await this.getGenreByIDQuery(genreID).async(); return { ...book, genre }; }, ); }     ","version":"Next","tagName":"h3"},{"title":"Тестирование SUT, использующих Repositories​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#тестирование-sut-использующих-repositories","content":" В других слоях приложения для работы с данными доступны только Repositories.  Подмена Repositories при тестировании SUT​  При тестировании SUT, Repositories необходимо подменять моками или стабами.  Использование реальных экземпляров Repositories, в которых подменяются Sources недопустимо потому, что это раскрывает детали имплементации Repositories и приводит к повышению хрупкости тестов.  Пример  class GoodsListStore { constructor(private readonly bookRepository: BookRepository) { makeAutoObservable(this); } private get listQuery() { return this.bookRepository.getBookListQuery(); } public get list(): ListItem[] { const data = this.listQuery.data?.data || []; return data.map(({ id, name, price }) =&gt; ({ id, name, price: formatPriceToView(price), store: createProductCartManagerStore(id), })); } }   Invalid  describe('GoodsListStore', () =&gt; { it('Список книг форматируется для отображения', async () =&gt; { const cacheService = createCacheService(); const fakeBookList = bookNetworkSourcesFaker.makeBookList(); const fakeBookListItem = fakeBookList.data[0]; const bookSourcesMock = mock&lt;BookNetworkSources&gt;({ getBookByName: async () =&gt; makeFakeSourceRes(fakeBookList), }); const bookRepository = new BookRepository(bookSourcesMock, cacheService); const sut = new GoodsListStore(bookRepository); // ждем автоматической загрузки данных await when(() =&gt; Boolean(sut.list?.length)); expect(sut.list[0]).toContain({ id: fakeBookListItem.id, name: fakeBookListItem.name, price: '1 000 руб.', }); }); });   Valid  describe('GoodsListStore', () =&gt; { it('Список книг форматируется для отображения', async () =&gt; { const cacheService = createCacheService(); const fakeBookList = bookRepositoryFaker.makeBookList(2, { price: 1000 }); const fakeBookListItem = fakeBookList.data[0]; const bookRepositoryMock = mock&lt;BookRepository&gt;({ getBookListQuery: () =&gt; cacheService.createQuery(['id'], async () =&gt; fakeBookList), }); const sut = new GoodsListStore(bookRepositoryMock); // ждем автоматической загрузки данных await when(() =&gt; Boolean(sut.list?.length)); expect(sut.list[0]).toContain({ id: fakeBookListItem.id, name: fakeBookListItem.name, price: '1 000 руб.', }); }); });     Faker для Repositories​  Для каждого Repository должен создаваться свой faker.  Расположение faker​  Faker располагается непосредственно рядом с Repository:  ├── app/ ├── screens/ ├── modules/ ├── data/ | ├── repositories/ | | ├── CartRepository/ | | | ├── CartRepository.ts | | | ├── dto.ts | | | ├── faker.ts | | | └── index.ts | | └── index.ts | ├── sources/ | | ├── CartNetworkSources/ | | | ├── CartNetworkSources.ts | | | ├── dto.ts | | | ├── faker.ts | | | └── index.ts | | └── index.ts | └── index.ts └── shared/   Переиспользование фейков sources​  Faker Repository может использовать для генерации данных faker’ы sources:  export const bookRepositoryFaker = { makeBookList( length?: number, item?: Partial&lt;BookRepositoryDTO.BookListItem&gt;, ): BookRepositoryDTO.BookListDTO { return bookNetworkSourcesFaker.makeBookList(length, item); }, makeBookByName(): BookRepositoryDTO.BookByName { return { ...bookNetworkSourcesFaker.makeBookByName(), genre: bookNetworkSourcesFaker.makeGenre(), }; }, };   Faker sources не доступны вне слоя data.  Использование faker для моков Repository​  При тестировании сущностей, находящихся в слоях отличных от data для repositories необходимо использовать mock.  Создавать mock необходимо на основе интерфейсов, а не реализации:  Создание mocks и stubs  Пример подмены repository c использованием faker:  describe('GoodsListStore', () =&gt; { it('Список книг форматируется для отображения', async () =&gt; { const cacheService = createCacheService(); const fakeBookList = bookRepositoryFaker.makeBookList(2, { price: 1000 }); const fakeBookListItem = fakeBookList.data[0]; const bookRepositoryMock = mock&lt;BookRepository&gt;({ getBookListQuery: () =&gt; cacheService.createQuery(['id'], async () =&gt; fakeBookList), }); const sut = new GoodsListStore(bookRepositoryMock); await when(() =&gt; Boolean(sut.list?.length)); expect(sut.list[0]).toContain({ id: fakeBookListItem.id, name: fakeBookListItem.name, price: '1 000 руб.', }); }); });     Тестирование взаимодействия SUT с Repository​  Если тест должен проверить правильность данных передаваемых в repository, то проверка должна осуществляться на границе взаимодействия repository и SUT - проверять вызов на mock repository:  class CardPaymentStore { constructor( private readonly cartStore: CartStore, private readonly paymentRepository: PaymentRepository, ) { makeAutoObservable(this); } private get paymentMutation() { return this.paymentRepository.createPaymentByCardMutation(); } public pay = (params?: { onSuccess: () =&gt; void }) =&gt; { const { onSuccess } = params || {}; const goodsId = this.cartStore.goods.map(({ id }) =&gt; id); this.paymentMutation.sync({ params: goodsId, onSuccess, }); }; }   describe('CardPaymentStore', () =&gt; { it('На оплату отправляются все товары из корзины', () =&gt; { const fakeGoodsList = cartRepositoryFaker.makeGoodsList(2); const mutationMock = mock&lt;ReturnType&lt;PaymentRepository['createPaymentByCardMutation']&gt;&gt;(); const cartStoreMock = mock&lt;CartStore&gt;({ goods: fakeGoodsList, }); const paymentRepositoryMock = mock&lt;PaymentRepository&gt;({ createPaymentByCardMutation: () =&gt; mutationMock, }); const sut = new CardPaymentStore(cartStoreMock, paymentRepositoryMock); sut.pay(); expect(mutationMock.sync.mock.lastCall?.[0]?.params).toEqual([ fakeGoodsList[0].id, fakeGoodsList[1].id, ]); }); });     ","version":"Next","tagName":"h3"},{"title":"Contract First подход​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#contract-first-подход","content":" Для того, чтобы разработку frontend и backend части можно было вести параллельно используется Contract First подход: backend заранее формирует интерфейсы, по которым будет взаимодействовать с API клиентское приложение.  Astral Architecture Guide предоставляет инструмент для удобной разработки по Contract First подходу.  ","version":"Next","tagName":"h2"},{"title":"Фейковые sources​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#фейковые-sources","content":" Для каждого sources может быть создана своя фейковая версия в файле faker:  ├── app/ ├── screens/ ├── modules/ ├── data/ | ├── repositories/ | ├── sources/ | | ├── CartNetworkSources/ | | | ├── CartNetworkSources.ts | | | ├── dto.ts | | | ├── faker.ts | | | └── index.ts | | └── index.ts | └── index.ts └── shared/   data/sources/CartNetworkSources/faker.ts  export const fakeCartNetworkSources: CartNetworkSources = { ...cartNetworkSources, getGoods: async () =&gt; makeFakeSourceRes(cartNetworkSourcesFaker.makeGoodsList()), getGoodsCount: async () =&gt; makeFakeSourceRes(10), };   Благодаря использованию DI для repositories происходит подмена реального sources на фейковый:  export const cartRepository = new CartRepository( fakeCartNetworkSources, cacheService, );   Теперь разработчик может реализовывать новую фичу по Contract First подходу, при чем вся система, кроме sources, будет работать также как на production.  После успешной реализации API просто меняем фейковый sources на реальный:  export const cartRepository = new CartRepository( cartNetworkSources, cacheService, );   ","version":"Next","tagName":"h3"},{"title":"Преимущества использования фейковых sources​","type":1,"pageTitle":"Data","url":"/guides/docs/arch/data#преимущества-использования-фейковых-sources","content":" Подмена данных происходит на самом краю архитектуры - sources. Благодаря этому вся система, за исключением sources, работает идентично production.Нет необходимости самостоятельно придумывать тестовые данныеБлагодаря генерации фейковых данных вероятность отлова бага на раннем этапе разработки увеличивается (например, ошибки переполнения в верстке) ","version":"Next","tagName":"h3"},{"title":"Единый Permissions Module","type":0,"sectionRef":"#","url":"/guides/docs/permissions/permissionsModule","content":"","keywords":"","version":"Next"},{"title":"Состав permissions модуля​","type":1,"pageTitle":"Единый Permissions Module","url":"/guides/docs/permissions/permissionsModule#состав-permissions-модуля","content":" Логика формирования доступовТипы доступных в приложении доступовПричины отказа в доступахЛогика блокировки рутов приложения  ","version":"Next","tagName":"h2"},{"title":"Причины концентрации логики доступов в одном модуле​","type":1,"pageTitle":"Единый Permissions Module","url":"/guides/docs/permissions/permissionsModule#причины-концентрации-логики-доступов-в-одном-модуле","content":" Контроль доступов приложения в одной точкеРасчет доступов, в большинстве случаев, связан с данными, которые необходимо получать из других модулей. Если формировать доступы на уровне конкретного модуля, то возникнет нежелательное зацепление между модулямиДоступы, мнимо относящиеся к разным модулям, будут использованы в других модулях, что также породит нежелательное зацеплениеПравила, позволяющие вычислять доступы, должны быть переиспользованы. Хранение правил в одном модуле позволит избежать зацепления модулейПричины отказа в доступе и логика для расчета доступов должна использоваться между доступами. Не централизованное хранение причин отказа и логики приведен к высокому зацеплению в системеВозможность централизованной подготовки данных для формирования базовых доступов  ","version":"Next","tagName":"h2"},{"title":"Пример с нежелательным зацеплением​","type":1,"pageTitle":"Единый Permissions Module","url":"/guides/docs/permissions/permissionsModule#пример-с-нежелательным-зацеплением","content":" Требования  Кнопка &quot;Добавить документ&quot; доступна только если есть подключенная организацияКнопка &quot;Удалить организацию&quot; доступна только если в рамках данной организации не было создано документов  Решение с зацеплением  Модуль docs реализует доступ docActions, который импортирует логику из модуля organization для проверки данных об организации. Модуль organization реализует доступ deletingOrganization, который импортирует логику из модуля docs для проверки данных о документах.  Получаем циклическую зависимость и зацепление между модулями.  Решение без зацепления  Модуль permissions содержит доступы docActions и deletingOrganization, импортируя логику из модулей docs и organization.  Модуль docs и organization теперь не зацеплены между собой. ","version":"Next","tagName":"h3"},{"title":"Feature Toggle и Permissions","type":0,"sectionRef":"#","url":"/guides/docs/permissions/featureToggle","content":"","keywords":"","version":"Next"},{"title":"Permissions может использовать Feature Toggle​","type":1,"pageTitle":"Feature Toggle и Permissions","url":"/guides/docs/permissions/featureToggle#permissions-может-использовать-feature-toggle","content":" Permissions может использовать Feature Toggle только в том случае, если Feature Toggle предоставляет Permissioning Toggles.  В противном случае Feature Toggle должен использоваться отдельно от Permissions. ","version":"Next","tagName":"h2"},{"title":"Policies. Политики доступов","type":0,"sectionRef":"#","url":"/guides/docs/permissions/policies","content":"","keywords":"","version":"Next"},{"title":"Местоположение​","type":1,"pageTitle":"Policies. Политики доступов","url":"/guides/docs/permissions/policies#местоположение","content":" Все политики находятся в директории policies:  ├── modules/ | ├── permissions/ | | ├── domain/ | | | ├── stores/ | | | | ├── PermissionsStore/ | | | | | ├── policies/ | | | | | | |── AdministrationPolicyStore/ | | | | | | |── BooksPolicyStore/ | | | | | | |── PaymentPolicyStore/ | | | | | | └── index.ts | | | | | ├── PermissionsStore.ts | | | | | └── index.ts | | | | └── index.ts | | | ├── enums.ts | | | └── index.ts   Policies являются частью имплементации PermissionStore, поэтому находятся внутри него.  ","version":"Next","tagName":"h2"},{"title":"Создание политик​","type":1,"pageTitle":"Policies. Политики доступов","url":"/guides/docs/permissions/policies#создание-политик","content":" ","version":"Next","tagName":"h2"},{"title":"Политики напрямую связаны с модулями системы​","type":1,"pageTitle":"Policies. Политики доступов","url":"/guides/docs/permissions/policies#политики-напрямую-связаны-с-модулями-системы","content":" Modules - это предметные подобласти предметной области проекта.  Permissions внутри policies работают в рамках предметных подобласть проекта, поэтому policies должны соответствовать названию modules.  Примеры  Permission administrationActions концептуально относится к модулю administration, поэтому создается AdministrationPolicyPermission readingBook концептуально относится к модулю books, поэтому создается BooksPolicy  ","version":"Next","tagName":"h3"},{"title":"Пример создания с использованием @astral/permissions​","type":1,"pageTitle":"Policies. Политики доступов","url":"/guides/docs/permissions/policies#пример-создания-с-использованием-astralpermissions","content":" modules/permissions/domain/stores/PermissionsStore/policies/AdministrationPolicyStore  import { makeAutoObservable } from 'mobx'; import type { UserRepository } from '@example/data'; import { PermissionDenialReason } from '../../../../enums'; // @astral/permissions в реальном коде должен реэкспортироваться через shared import { PolicyManagerStore, Policy } from '@astral/permissions'; export class AdministrationPolicyStore { private readonly policy: Policy; constructor( private readonly policyManager: PolicyManagerStore, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); // policyManager.createPolicy создает политику, которая позволит в дальнейшем создавать permissions this.policy = this.policyManager.createPolicy({ name: 'administration', // Метод для подготовки данных необходимых для формирования доступов AdministrationPolicy prepareData: async (): Promise&lt;void&gt; =&gt; { await Promise.all([this.userRepo.getRolesQuery().async()]); }, }); } }   ","version":"Next","tagName":"h3"},{"title":"Доступ к политикам через единую точку PermissionsStore​","type":1,"pageTitle":"Policies. Политики доступов","url":"/guides/docs/permissions/policies#доступ-к-политикам-через-единую-точку-permissionsstore","content":" PermissionsStore - это singleton и единая входная точка в приложении для получения информации о доступах.  Другие модули приложения взаимодействуют именно с PermissionStore.  Пример реализации:  import { makeAutoObservable } from 'mobx'; import { billingRepository, userRepository } from '@example/data'; import type { BillingRepository, UserRepository } from '@example/data'; // В реальном коде @astral/permissions необходимо реэкспортировать через shared import type { PolicyManagerStore } from '@astral/permissions'; import { createPolicyManagerStore } from '@astral/permissions'; import { createAdministrationPolicyStore, createBooksPolicyStore, createPaymentPolicyStore, } from './policies'; import type { AdministrationPolicyStore, BooksPolicyStore, PaymentPolicyStore, } from './policies'; /** * Содержит все доступы приложения */ export class PermissionsStore { private readonly policyManager: PolicyManagerStore; public readonly administration: AdministrationPolicyStore; public readonly books: BooksPolicyStore; constructor(billingRepo: BillingRepository, userRepo: UserRepository) { makeAutoObservable(this, {}, { autoBind: true }); // policyManager регистрирует все доступы и позволяет подготовить данные для формирования доступов this.policyManager = createPolicyManagerStore(); this.administration = createAdministrationPolicyStore( this.policyManager, userRepo, ); this.books = createBooksPolicyStore( this.policyManager, billingRepo, userRepo, ); } /** * Подготавливает данные для формирования доступов */ public prepareData = () =&gt; this.policyManager.prepareDataSync(); public get preparingDataStatus() { return this.policyManager.preparingDataStatus; } } // singleton export const permissionsStore = new PermissionsStore( billingRepository, userRepository, );   Пример использования:  export class UIStore { constructor(private readonly permissions: PermissionsStore) { makeAutoObservable(this, {}, { autoBind: true }); } public get isAllowedBookCreation() { return this.permissions.administration.administrationActions.isAllowed; } }   Мотивация  Возможность централизованной подготовки данных для формирования permissionsВозможность реализации логирования для дебагингаУвеличение DX за счет отказа от необходимо импорта разных policies  ","version":"Next","tagName":"h2"},{"title":"Переиспользование логики между policies​","type":1,"pageTitle":"Policies. Политики доступов","url":"/guides/docs/permissions/policies#переиспользование-логики-между-policies","content":" Policies не должны зависеть друг от друга и соответственно переиспользовать permissions потому.  Переиспользование permissions между policies приводит к пересечению бизнес требований и запутанной логике формирования доступов.  Если между policies необходимо переиспользовать логику, то надо использовать rules. ","version":"Next","tagName":"h2"},{"title":"Reasons. Причины отказа в доступе","type":0,"sectionRef":"#","url":"/guides/docs/permissions/reasons","content":"","keywords":"","version":"Next"},{"title":"Пример использования​","type":1,"pageTitle":"Reasons. Причины отказа в доступе","url":"/guides/docs/permissions/reasons#пример-использования","content":" Требования  Пользователь не может добавить книгу на свою полку, если:  Аккаунт не оплаченПревышено доступное количество книг, которое можно добавить на полку  Если у пользователя не оплачен аккаунт, то при нажатии на кнопку &quot;Добавить на полку&quot; должна открыться модалка с предложением об оплате. Если пользователь достиг предел добавленных книг на полку, то необходимо отобразить уведомление &quot;Достигнуто максимальное количество книг на полке&quot;.  Решение  modules/permissions/domain/stores/PermissionsStore/policies/BooksPolicy  // @astral/permissions в реальном коде должен реэкспортироваться через shared import { PolicyManagerStore, Policy } from '@astral/permissions'; export class BooksPolicyStore { private readonly policy: PermissionsPolicy; constructor( policyManager: PolicyManagerStore, private readonly billingRepo: BillingRepository, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policy = policyManager.createPolicy({ name: 'books', prepareData: async () =&gt; { await Promise.all([ this.userRepo.getRolesQuery().async(), this.billingRepo.getBillingInfoQuery().async(), ]); }, }); } /** * Возможность добавить на полку книгу */ public get addingToShelf() { return this.policy.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } const billingInfo = this.billingRepo.getBillingInfoQuery()?.data; if (!billingInfo?.paid) { return deny(PermissionDenialReason.NoPayAccount); } if ( billingInfo.info.shelf.currentCount &gt;= billingInfo.info.shelf.allowedCount ) { return deny(PermissionDenialReason.ExceedShelfCount); } allow(); }); } }   modules/books/features/BookCard/UIStore  // В реальном коде для импорта из другого модуля необходимо использовать external файл import { PermissionDenialReason, PermissionsStore, permissionsStore, } from '@example/modules/permissions'; export class UIStore { public isOpenPayAccount = false; constructor( private readonly bookId: string, private readonly permissions: PermissionsStore, private readonly notifyService: Notify, ) { makeAutoObservable(this, {}, { autoBind: true }); } public addToShelf = () =&gt; { if (this.permissions.books.addingToShelf.isAllowed) { this.notifyService.info(`Книга ${this.bookId} добавлена на полку`); return; } if (this.permissions.books.addingToShelf.hasReason(PermissionDenialReason.NoPay)) { this.openPaymentAccount(); return; } if ( this.permissions.books.addingToShelf.hasReason(PermissionDenialReason.ExceedReadingCount) ) { this.notifyService.error( 'Достигнуто максимальное количество книг на полке', ); return; } this.notifyService.error( 'Добавить книгу на полку нельзя. Попробуйте перезагрузить страницу', ); }; public openPayAccount = () =&gt; { this.isOpenPayAccount = true; }; public closePayAccount = () =&gt; { this.isOpenPayAccount = false; }; } export const createUIStore = (bookId: string) =&gt; new UIStore(bookId, permissionsStore, notify);   modules/books/features/BookCard/BookCard.tsx  type Props = { id: string; }; export const BookCard = observer(({ id }: Props) =&gt; { const [{ addToShelf, isOpenPayAccount, closePayAccount }] = useState(() =&gt; createUIStore(id)); return ( &lt;&gt; &lt;Container&gt; &lt;BookInfo /&gt; &lt;Button onClick={addToShelf}&gt;Добавить на полку&lt;/Button&gt; &lt;/Container&gt; &lt;PayAccountModal isOpen={isOpenPayAccount} onClose={closePayAccount} /&gt; &lt;/&gt; ); });   ","version":"Next","tagName":"h2"},{"title":"Все reasons хранятся в одном enum​","type":1,"pageTitle":"Reasons. Причины отказа в доступе","url":"/guides/docs/permissions/reasons#все-reasons-хранятся-в-одном-enum","content":" Одни и те же причины отказа переиспользуются между разными permissions и policies.  Все reasons необходимо хранить в одном enum для того, чтобы не создавать дополнительные сложности декомпозиции при росте причин.  Reasons должны располагаться в modules/permissions/domain/enums.ts:  export enum PermissionDenialReason { /** * Не является администратором * **/ NoAdmin = 'no-admin', /** * Аккаунт не оплачен * **/ NoPayAccount = 'no-pay-account', }   Пакет @astral/permissions содержит дополнительные системные причины отказа, которые могут произойти из-за ошибок в коде:  export enum SystemDenialReason { /** * При расчете доступа произошла ошибка * **/ InternalError = 'internal-error', /** * Недостаточно данных для формирования доступа * **/ MissingData = 'missing-data', }   Для централизованного хранения reasons, необходимо объединить SystemDenialReason и reasons нашего модуля:  import { SystemDenialReason } from '@astral/permissions'; export enum PermissionsDenialReason { /** * При расчете доступа произошла ошибка * **/ InternalError = SystemDenialReason.InternalError, /** * Недостаточно данных для формирования доступа * **/ MissingData = SystemDenialReason.MissingData, /** * Пользователь не является админом * **/ NoAdmin = 'no-admin', }   ","version":"Next","tagName":"h2"},{"title":"Соглашения​","type":1,"pageTitle":"Reasons. Причины отказа в доступе","url":"/guides/docs/permissions/reasons#соглашения","content":" Для каждого reason должен быть оставлен комментарий в виде jsdoc о предназначении данного reasonЗначения reasons должны быть String в формате kebab-case ","version":"Next","tagName":"h2"},{"title":"Подготовка данных для доступов","type":0,"sectionRef":"#","url":"/guides/docs/permissions/preparingData","content":"","keywords":"","version":"Next"},{"title":"Каждая policy указывает какие данные нужны для доступов​","type":1,"pageTitle":"Подготовка данных для доступов","url":"/guides/docs/permissions/preparingData#каждая-policy-указывает-какие-данные-нужны-для-доступов","content":" Каждая policy определяет метод подготовки данных, которые нужны для формирования запросов.  ","version":"Next","tagName":"h2"},{"title":"Пример​","type":1,"pageTitle":"Подготовка данных для доступов","url":"/guides/docs/permissions/preparingData#пример","content":" В BooksPolicy для формирования доступа addingToShelf требуются данные из UserRepository и BillingRepository.  При создании policy необходимо указать как получить эти данные:  // @astral/permissions в реальном коде должен реэкспортироваться через shared import { PolicyManagerStore, Policy } from '@astral/permissions'; export class BooksPolicyStore { private readonly policy: PermissionsPolicy; constructor( policyManager: PolicyManagerStore, private readonly billingRepo: BillingRepository, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policy = policyManager.createPolicy({ name: 'books', // prepareData будет вызван одновременно с другими policy посредством policyManager prepareData: async () =&gt; { await Promise.all([ this.userRepo.getRolesQuery().async(), this.userRepo.getPersonInfoQuery().async(), this.billingRepo.getBillingInfoQuery().async(), ]); }, }); } /** * Возможность добавить на полку книгу */ public get addingToShelf() { return this.policy.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } const billingInfo = this.billingRepo.getBillingInfoQuery()?.data; if (!billingInfo?.paid) { return deny(PermissionDenialReason.NoPayAccount); } if ( billingInfo.info.shelf.currentCount &gt;= billingInfo.info.shelf.allowedCount ) { return deny(PermissionDenialReason.ExceedShelfCount); } allow(); }); } }   ","version":"Next","tagName":"h3"},{"title":"PermissionsStore.prepareData подготовит данные для всех policy​","type":1,"pageTitle":"Подготовка данных для доступов","url":"/guides/docs/permissions/preparingData#permissionsstorepreparedata-подготовит-данные-для-всех-policy","content":" PermissionsStore должен иметь метод prepareData, который вызовет подготовку данных в каждом policy:  // В реальном коде @astral/permissions необходимо реэкспортировать через shared import type { PolicyManagerStore } from '@astral/permissions'; import { createPolicyManagerStore } from '@astral/permissions'; /** * Содержит все доступы приложения */ export class PermissionsStore { private readonly policyManager: PolicyManagerStore; public readonly administration: AdministrationPolicyStore; public readonly books: BooksPolicyStore; constructor(billingRepo: BillingRepository, userRepo: UserRepository) { makeAutoObservable(this, {}, { autoBind: true }); // policyManager регистрирует все доступы и позволяет подготовить данные для формирования доступов this.policyManager = createPolicyManagerStore(); this.administration = createAdministrationPolicyStore( this.policyManager, userRepo, ); this.books = createBooksPolicyStore( this.policyManager, billingRepo, userRepo, ); } /** * Подготавливает данные для формирования доступов */ public prepareData = () =&gt; this.policyManager.prepareDataSync(); public get preparingDataStatus() { return this.policyManager.preparingDataStatus; } }   За подготовку данных отвечает PolicyManagerStore. PolicyManagerStore регистрирует для каждого policy метод подготовки prepareDataи при вызове policyManager.prepareData запускает вызов каждой prepareData каждого policy  Мотивация использования единого метода подготовки данных  Выбран подход использования единого метода для загрузки данных для того, чтобы соблюдать баланс между сложностью использования и оптимизацией загрузки данных:  Если вызывать для каждой policy или для каждого permission отдельный метод загрузки данных, то все фичи приложения, использующие доступы, должны будут быть обернуты в ContentStateНеобходимо следить за запросами, которые вызываются в методах подготовки данных - они не должны быть медленными потому, что блокируют рендеринг приложения  ","version":"Next","tagName":"h2"},{"title":"Использование​","type":1,"pageTitle":"Подготовка данных для доступов","url":"/guides/docs/permissions/preparingData#использование","content":" PermissionsStore.prepareData необходимо вызывать в application слое приложения:  application/app.tsx   export const App = observer(() =&gt; { const renderRoutes = useRoutes(routes); const permissionsStatus = permissionsStore.preparingDataStatus; useEffect(() =&gt; { permissionsStore.prepareData(); authStore.addProtectedHttpClients([apiHttpClient]); }, []); return ( &lt;ThemeProvider theme={theme}&gt; &lt;NotificationContainer /&gt; &lt;ContentState isError={permissionsStatus.isError} isLoading={permissionsStatus.isLoading} errorState={{ errorList: [permissionsStatus.error], onRetry: permissionsStore.prepareData, }} &gt; &lt;MainLayout&gt;{renderRoutes}&lt;/MainLayout&gt; &lt;/ContentState&gt; &lt;/ThemeProvider&gt; ); });   Не рекомендуется рендерить приложение, пока данные для permissions не будут успешно подготовлены.  ","version":"Next","tagName":"h3"},{"title":"Оптимизация PermissionsStore.prepareData​","type":1,"pageTitle":"Подготовка данных для доступов","url":"/guides/docs/permissions/preparingData#оптимизация-permissionsstorepreparedata","content":" Необходимо следить за запросами, которые вызываются в методах подготовки данных - они не должны быть медленными потому, что блокируют рендеринг приложения.  Запросы могут использоваться в prepareData, если:  Запрашиваемые данные нужны для рендеринга приложения не только в PermissionsStoreЗапрашиваемые данные значительно не влияют на блокировку рендера приложения  Если запросы являются не оптимальными для использования в PermissionsStore, то для формирования permissions необходимо использовать методы, принимающие на вход данные:  import { calcAcceptableAge } from '../../rules'; export class PaymentPolicyStore { private readonly policy: PermissionsPolicy; constructor( policyManager: PermissionsPolicyManagerStore, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policy = policyManager.createPolicy({ name: 'payment', prepareData: async () =&gt; { await Promise.all([userRepo.getPersonInfoQuery().async()]); }, }); } /** * Возможность оплатить товар */ public calcPayment = (acceptableAge: number) =&gt; this.policy.createPermission((allow, deny) =&gt; { const agePermission = calcAcceptableAge( acceptableAge, this.userRepo.getPersonInfoQuery().data?.birthday, ); if (!agePermission.isAllowed) { return deny(agePermission.reason); } allow(); }); }   В таком случае за получение данных будет ответственна та часть приложения, которая будет использовать permission:  modules/books/features/BookCard/UIStore  export class UIStore { public isOpenPayAccount = false; constructor( private readonly bookId: string, private readonly permissions: PermissionsStore, private readonly notifyService: Notify, private readonly booksRepo: BooksRepository ) { makeAutoObservable(this, {}, { autoBind: true }); } private get bookByIdQuery() { return this.booksRepo.getBookByIdQuery(this.bookId); } public buy = () =&gt; { const payPermission = this.permissions.calcPayment(this.bookByIdQuery.acceptableAge); if (payPermission.isAllowed) { this.notifyService.success(`Книга ${bookId} оплачена`); return; } if (payPermission.hasReason(PermissionDenialReason.NotAcceptAge)) { this.notifyService.error('Вы слишком молоды'); return; } this.notifyService.error( 'Купить книгу нельзя. Попробуйте перезагрузить страницу', ); }; public openPayAccount = () =&gt; { this.isOpenPayAccount = true; }; public closePayAccount = () =&gt; { this.isOpenPayAccount = false; }; }   ","version":"Next","tagName":"h2"},{"title":"Обработка проблем получения данных​","type":1,"pageTitle":"Подготовка данных для доступов","url":"/guides/docs/permissions/preparingData#обработка-проблем-получения-данных","content":" Если перед использованием permissions в features, не были успешно загружены данные, то permissions будут возвращать объект с конкретным reason:  type DenialMissingDataPermission = { isAllowed: false; reason: PermissionDenialReason.MissingData; };   Reason PermissionDenialReason.MissingData можно будет при необходимости обработать централизованно или на месте использования permissions.  ","version":"Next","tagName":"h2"},{"title":"Создание policy без preparingData​","type":1,"pageTitle":"Подготовка данных для доступов","url":"/guides/docs/permissions/preparingData#создание-policy-без-preparingdata","content":" Некоторые policy состоят полностью из permissions, для которых данные для формирования принимаются через параметры:  export class PaymentPolicyStore { private readonly policy: PermissionsPolicy; constructor( policyManager: PermissionsPolicyManagerStore, private readonly userRepo: UserRepository, ) { ... } // calcPayment использует только age из параметра public calcPayment = (age: number) =&gt; this.policy.createPermission((allow, deny) =&gt; { if (age &lt; 18) { return deny(PermissionsDenialReason.MinorAge); } allow(); }); // calcPaymentFromOrg использует только org из параметра public calcPaymentFromOrg = (org: Organization) =&gt; this.policy.createPermission((allow, deny) =&gt; { if (!org.permissions.includes('admin')) { return deny(PermissionsDenialReason.NoAdmin); } allow(); }); }   Для таких случаев в пакете @astral/permissions предусмотрен флаг withoutDataPreparation при создании policy:   export class PaymentPolicyStore { private readonly policy: PermissionsPolicy; constructor( policyManager: PermissionsPolicyManagerStore, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, {autoBind: true}); this.policy = policyManager.createPolicy({ name: 'payment', withoutDataPreparation: true, }); } }   Проброс флага позволит не указывать prepareData для конкретного policy.  Важно​  Вызов PermissionsStore.prepareData необходим даже если все policy были созданы с флагом withoutDataPreparation. Это необходимо для надежности формирования доступов, если один из policy начнет использовать prepareData. ","version":"Next","tagName":"h2"},{"title":"Формирование доступов","type":0,"sectionRef":"#","url":"/guides/docs/permissions/permissionsFormation","content":"","keywords":"","version":"Next"},{"title":"Как выделять permission​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#как-выделять-permission","content":" Требование является permission, если:  Требование указывает на то, что функционал приложения должен быть ограничен на основе данных об аккаунте (роль, организация, оплата...)Описанное ограничение может быть снято при изменении данных пользователя  Permission не является:  Временный Feature Toggle на функционалПерманентное условие на блокировку функционала, без возможности открытия доступа (даже при изменении роли пользователя)Условия (if) в коде, реализующие рядовые бизнес требования  ","version":"Next","tagName":"h2"},{"title":"Примеры требований​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#примеры-требований","content":" Кнопка &quot;Создать документ&quot; доступна только администратору - это permission потому, что ограничение основывается на данных пользователя и доступ к функционалу можно открыть, если изменить роль пользователя.  Кнопка &quot;Редактировать документ&quot; доступна только для пользователей с платным аккаунтом и добавленной организацией - это permission потому, что ограничение основывается на данных пользователя и доступ к функционалу можно открыть, если оплатить аккаунт и добавить организацию.  Кнопка &quot;Создать документ&quot; заблокирована до 20.05.2024 - это не permission, а feature toggle. Требование не зависит от данных пользователя.  При этом:  Кнопка &quot;Создать документ&quot; для пользователей с тарифом &quot;Базовый&quot; заблокирована до 20.05.2024 - это уже permission потому, что основывается на данных пользователя.  Кнопка &quot;Отправить&quot; заблокирована, если чекбокс &quot;Ознакомлен с требованиями&quot; не активен - это не permission. Это требование для формы.  ","version":"Next","tagName":"h3"},{"title":"Создание permissions посредством @astral/permissions​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#создание-permissions-посредством-astralpermissions","content":" Permissions создаются только внутри policy с помощью метода policy.createPermission:  modules/permissions/domain/stores/PermissionsStore/policies/AdministrationPolicyStore  import { makeAutoObservable } from 'mobx'; import type { UserRepository } from '@example/data'; import { PermissionDenialReason } from '../../../../enums'; // @astral/permissions в реальном коде должен реэкспортироваться через shared import { PolicyManagerStore, Policy } from '@astral/permissions'; export class AdministrationPolicyStore { private readonly policy: Policy; constructor( private readonly policyManager: PolicyManagerStore, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policy = this.policyManager.createPolicy({ name: 'administration', prepareData: async (): Promise&lt;void&gt; =&gt; { await Promise.all([this.userRepo.getRolesQuery().async()]); }, }); } /** * Доступ к действиям администратора */ public get administrationActions() { return this.policy.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { // разрешает доступ return allow(); } // запрещает доступ с конкретной причиной deny(PermissionDenialReason.NoAdmin); }); } }   ","version":"Next","tagName":"h2"},{"title":"API Permission​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#api-permission","content":" createPermission возвращает объект вида:  type Permission = { isAllowed: boolean; /** * Причина отказа в доступе */ reason?: string; /** * @example permission.hasReason(DenialReason.NoAdmin) */ hasReason: (reason: string) =&gt; boolean; };   О причинах отказа читайте далее.  ","version":"Next","tagName":"h3"},{"title":"Пример реализации и использования permission​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#пример-реализации-и-использования-permission","content":" Требования  Кнопка &quot;Создать книгу&quot; в Sidebar отображается только если пользователь является администратором.  Решение  modules/permissions/domain/stores/PermissionsStore/policies/AdministrationPolicyStore  class AdministrationPolicyStore { constructor( private readonly policyManager: PolicyManagerStore, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policyManager.createPolicy({ name: 'administration', prepareData: async (): Promise&lt;void&gt; =&gt; { await Promise.all([this.userRepo.getRolesQuery().async()]); }, }); } /** * Доступ к действиям администратора */ public get administrationActions() { return this.policyManager.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } deny(PermissionDenialReason.NoAdmin); }); } }   В features необходимо избегать разрешения доступов через абстрактные компоненты вида:  import { observer } from 'mobx-react-lite'; import { permissionsStore } from '@example/modules/permissions'; export const Sidebar = observer(() =&gt; { return ( &lt;Sidebar&gt; &lt;PermissionsGateway permission={permissionsStore.administration.administrationActions} allow={ &lt;RouterLink to={APP_ROUTES.createBook.getRedirectPath()}&gt; Создать книгу &lt;/RouterLink&gt; } /&gt; &lt;/Sidebar&gt; ); });   Использование компонентов вроде PermissionsGateway переносит логику доступов для фичи в UI слой, что нарушает архитектурную концепцию.  Разрешение доступов должно происходить в UIStore:  modules/layout/features/MainLayout/Sidebar/UIStore  export class UIStore { constructor(private readonly permissions: PermissionsStore) { makeAutoObservable(this, {}, { autoBind: true }); } public get isAllowedBookCreation() { return this.permissions.administration.administrationActions.isAllowed; } }   modules/layout/features/MainLayout/Sidebar/Sidebar.tsx  export const Sidebar = observer(() =&gt; { const [{ isAllowedBookCreation }] = useState(createUIStore); return ( &lt;Sidebar&gt; &lt;SidebarItem&gt; {isAllowedBookCreation &amp;&amp; ( &lt;RouterLink to={APP_ROUTES.createBook.getRedirectPath()}&gt; Создать книгу &lt;/RouterLink&gt; )} &lt;/SidebarItem&gt; &lt;/Sidebar&gt; ); });   ","version":"Next","tagName":"h2"},{"title":"Permission не должен зависеть от UI​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#permission-не-должен-зависеть-от-ui","content":" Permission не должен напрямую зависеть и указывать на UI, который блокируется. Зависимость от UI приведет к взрывному росту permissions и в последствии к сложной поддержке кода.  ","version":"Next","tagName":"h2"},{"title":"Пример​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#пример","content":" Кнопка &quot;Создать документ&quot; отображается только если пользователь является администратором - в данном требовании присутствует указать на конкретную кнопку.  Неправильное решение​  Создать permission showCreationDocButton:  class AdministrationPolicyStore { ... public get showCreationDocButton() { return this.policyManager.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } deny(PermissionDenialReason.NoAdmin); }); } public get allowAdministrationRoute() { return this.policyManager.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } deny(PermissionDenialReason.NoAdmin); }); } public get showEditingDocModal() { return this.policyManager.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } deny(PermissionDenialReason.NoAdmin); }); } }   Как видно из примера, при связывании permission и UI происходит взрывной рост одинаковых доступов:  Доступ к кнопкеДоступ к рутуДоступ к модалке редактирования  Правильное решение​  Создать абстрактный permission administrationActions, который будет закрывать доступ к действиям администратора:  class AdministrationPolicyStore { ... public get administrationActions() { return this.policyManager.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } deny(PermissionDenialReason.NoAdmin); }); } }   Теперь на уровне features необходимо проверять administrationActions и на основе его выполнять необходимые действия.  ","version":"Next","tagName":"h3"},{"title":"Нейминг​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#нейминг","content":" Название permission должно отвечать на вопрос: &quot;Доступ открыт/закрыт для чего/к чему?&quot;.  Примеры  Доступ закрыт к действиям администратора - administrationActionsДоступ закрыт к чтению книги онлайн - readingBookДоступ закрыт к управлению организацией - organizationManagement  ✅ Valid  public get administrationActions() { ... } public get addingToShelf() { ... } public get readingBook() { ... } public get organizationManagement() { ... }   ❌ Invalid  public get canReadingBook() { ... } public get isAddToShelf() { ... }   ","version":"Next","tagName":"h2"},{"title":"Нейминг методов для вычисления доступов​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#нейминг-методов-для-вычисления-доступов","content":" Для методов, которые вычисляют доступы, добавляется префикс calc.  ✅ Valid  public calcReadingBook = (bookId: string) =&gt; { ... }   ❌ Invalid  public checkReadingBook = (bookId: string) =&gt; { ... }  ","version":"Next","tagName":"h3"},{"title":"Route Guards. Доступы к рутам приложения","type":0,"sectionRef":"#","url":"/guides/docs/permissions/routes","content":"","keywords":"","version":"Next"},{"title":"Местоположение​","type":1,"pageTitle":"Route Guards. Доступы к рутам приложения","url":"/guides/docs/permissions/routes#местоположение","content":" Все Route Guards хранятся в modules/permissions/features/routeGuards:  ├── modules/ | ├── permissions/ | | ├── features/ | | | ├── routesGuards/ | | | | ├── AdminRouteGuard/ | | | | ├── ReadingBookRouteGuard/ | | | | └── index.ts | | | └── index.ts | | └── index.ts   ","version":"Next","tagName":"h2"},{"title":"Guard вызывается для каждой page​","type":1,"pageTitle":"Route Guards. Доступы к рутам приложения","url":"/guides/docs/permissions/routes#guard-вызывается-для-каждой-page","content":" Route Guard должен вызываться на каждой page, которая должна быть защищена доступами.  МотивацияВызов Route Guard для каждого page позволяет достичь простоты поддержки. При исследовании pages сразу видна связь страницы и доступов.  Использование конфигурации с описанием доступных рутов в модуле permissions значительно усложняет понимание кода и простоту поддержки функционала.  ","version":"Next","tagName":"h2"},{"title":"Пример​","type":1,"pageTitle":"Route Guards. Доступы к рутам приложения","url":"/guides/docs/permissions/routes#пример","content":" Необходимо закрыть pages:  admin/createBookbook/reading  ├── application/ | ├── pages/ | | ├── admin/ | | | ├── createBook.tsx | | ├── book/ | | | ├── reading.tsx ├── modules/ | ├── permissions/ | | ├── features/ | | | ├── routesGuards/ | | | | ├── AdminRouteGuard/ | | | | ├── ReadingBookRouteGuard/ | | | | └── index.ts | | | └── index.ts | | └── index.ts   application/pages/admin/createBook.tsx  import { CreationBookScreen } from '@example/screens'; import { AdminRouteGuard } from '@example/modules/permissions'; const CreateBookPage = () =&gt; { return ( &lt;AdminRouteGuard&gt; &lt;CreationBookScreen /&gt; &lt;/AdminRouteGuard&gt; ); }; export default CreateBookPage;   application/pages/book/reading.tsx  import { NotFoundScreen, ReadingBookScreen } from '@example/screens'; import { useRouterParams } from '@example/shared'; import { ReadingBookRouteGuard } from '@example/modules/permissions'; const ReadingBookPage = () =&gt; { const { id } = useRouterParams(); if (!id) { return &lt;NotFoundScreen title=&quot;Книга не найдена&quot; /&gt;; } return ( &lt;ReadingBookRouteGuard id={id}&gt; &lt;ReadingBookScreen id={id} /&gt; &lt;/ReadingBookRouteGuard&gt; ); }; export default ReadingBookPage;   ","version":"Next","tagName":"h3"},{"title":"Вложенные страницы​","type":1,"pageTitle":"Route Guards. Доступы к рутам приложения","url":"/guides/docs/permissions/routes#вложенные-страницы","content":" Использование Route Guard для каждой страницы создает небольшой overhead: для каждой вложенной страницы необходимо вызывать Route Guard, возможности закрыть всю вложенность нет.  Данное ограничение принимается в угоду более простой поддержки.  ","version":"Next","tagName":"h3"},{"title":"Создание Route Guard​","type":1,"pageTitle":"Route Guards. Доступы к рутам приложения","url":"/guides/docs/permissions/routes#создание-route-guard","content":" В modules/permissions/features/routeGuards необходимо создать Route Guard, который будет закрывать конкретную страницу или ряд страниц. Реализация зависит от требований.  Все Route Guard создаются на основе абстрактного PermissionRouteGuard.  PermissionRouteGuard - фасад, позволяющий упростить реализацию Route Guards и обработать стандартные причины отказа.  ","version":"Next","tagName":"h2"},{"title":"Пример​","type":1,"pageTitle":"Route Guards. Доступы к рутам приложения","url":"/guides/docs/permissions/routes#пример-1","content":" Требования  Страница создания книги (admin/createBook) должна быть доступна только администратору.  Реализация  В AdministrationPolicy уже реализован permissions - administrationActions, на основе которого можно делать вывод доступна ли пользователю страница создания книги.  На момент реализации, все вложенные руты в /admin подходят под administrationActions permission, поэтому реализуем единый для всех /admin/ Guard:  modules/permissions/features/routeGuards/AdminRouteGuard  import type { ReactNode } from 'react'; import { observer } from 'mobx-react-lite'; import { PageLayout, Placeholder } from '@example/shared'; import { PermissionDenialReason, permissionsStore } from '../../../domain'; import { PermissionGuard } from '../../PermissionGuard'; type Props = { children: ReactNode; }; export const AdminRouteGuard = observer(({ children }: Props) =&gt; { return ( &lt;PermissionGuard permission={permissionsStore.administration.administrationActions} denialSwitch={{ [PermissionDenialReason.NoAdmin]: ( &lt;PageLayout header={{ title: 'Панель администратора' }} content={{ children: ( &lt;Placeholder title=&quot;Доступно только для администраторов&quot; /&gt; ), }} /&gt; ), }} &gt; {children} &lt;/PermissionGuard&gt; ); });   denialSwitch позволяет обработать причины отказа. В данном случае, если причина отказа 'no-admin', то необходимо показать соответствующий Placeholder.  Закрывает требуемую страницу приложения:  application/pages/admin/createBook.tsx  import { CreationBookScreen } from '@example/screens'; import { AdminRouteGuard } from '@example/modules/permissions'; const CreateBookPage = () =&gt; { return ( &lt;AdminRouteGuard&gt; &lt;CreationBookScreen /&gt; &lt;/AdminRouteGuard&gt; ); }; export default CreateBookPage;   ","version":"Next","tagName":"h3"},{"title":"Обработка дефолтных причин отказа в доступе​","type":1,"pageTitle":"Route Guards. Доступы к рутам приложения","url":"/guides/docs/permissions/routes#обработка-дефолтных-причин-отказа-в-доступе","content":" В PermissionRouteGuard можно обработать дефолтные причины для отказа.  ","version":"Next","tagName":"h2"},{"title":"Пример​","type":1,"pageTitle":"Route Guards. Доступы к рутам приложения","url":"/guides/docs/permissions/routes#пример-2","content":" import { Placeholder } from '@example/shared'; import type { Permission } from '../../domain'; import { PermissionDenialReason } from '../../domain'; type Props = { permission: Permission; /** * Позволяет отрендерить компонент для конкретной причины отказа в доступе */ denialSwitch: Record&lt;string, ReactNode&gt;; children: ReactNode; }; /** * Закрывает доступ к children, обрабатывает дефолтные причины отказа */ export const PermissionGuard = ({ permission, denialSwitch, children, }: Props) =&gt; { if (permission.isAllowed) { return children; } if (denialSwitch[permission.reason]) { return denialSwitch[permission.reason]; } if (permission.reason === PermissionDenialReason.NoPayAccount) { return &lt;Placeholder title=&quot;Необходимо оплатить аккаунт&quot; /&gt;; } if (permission.reason === PermissionDenialReason.MissingUserAge) { return &lt;Placeholder title=&quot;Необходимо заполнить дату рождения в ЛК&quot; /&gt;; } return &lt;Placeholder title=&quot;Нет доступа&quot; /&gt;; };  ","version":"Next","tagName":"h3"},{"title":"Rules. Переиспользование логики доступов","type":0,"sectionRef":"#","url":"/guides/docs/permissions/rules","content":"","keywords":"","version":"Next"},{"title":"Местоположение​","type":1,"pageTitle":"Rules. Переиспользование логики доступов","url":"/guides/docs/permissions/rules#местоположение","content":" Все правила находятся в директории rules:  ├── modules/ | ├── permissions/ | | ├── domain/ | | | ├── stores/ | | | | ├── PermissionsStore/ | | | | | ├── policies/ | | | | | ├── rules/ | | | | | | |── calcAcceptableAge/ | | | | | | |── calcAccountPayment/ | | | | | | └── index.ts | | | | ├── PermissionsStore.ts | | | | └── index.ts | | | ├── enums.ts | | | └── index.ts   ","version":"Next","tagName":"h2"},{"title":"Rules - приватные функции модуля permissions​","type":1,"pageTitle":"Rules. Переиспользование логики доступов","url":"/guides/docs/permissions/rules#rules---приватные-функции-модуля-permissions","content":" Rules недоступны вне permissions модуля и являются частью имплементации PermissionsStore.  ","version":"Next","tagName":"h2"},{"title":"Реализация rules​","type":1,"pageTitle":"Rules. Переиспользование логики доступов","url":"/guides/docs/permissions/rules#реализация-rules","content":" Rules создаются с помощью createRule из пакета @astral/permissions:  ","version":"Next","tagName":"h2"},{"title":"Пример​","type":1,"pageTitle":"Rules. Переиспользование логики доступов","url":"/guides/docs/permissions/rules#пример","content":" Требования  Чтение книги доступно только если возраст пользователя соответствует доступному возрасту, указанному в книгеПокупка товара доступна только если возраст пользователя соответствует доступному возрасту, указанному в товаре  Решение  Требуется реализовать два permissions: calcReadingBook и calcPayment. Оба permissions должны реализовать одну и ту же логику проверки возраста пользователя. Необходимо реализовать rule: calcAcceptableAge:  modules/permissions/domain/stores/PermissionsStore/rules/calcAcceptableAge  // @astral/permissions в реальном коде необходимо реэкспортировать через shared import { createRule } from '@astral/permissions'; export const calcAcceptableAge = ( acceptableAge?: number, userBirthday?: string, ) =&gt; createRule((allow, deny) =&gt; { if (!acceptableAge) { return deny(PermissionDenialReason.MissingData); } if (!userBirthday) { return deny(PermissionDenialReason.MissingUserAge); } if (getDateYearDiff(new Date(userBirthday), new Date()) &lt; acceptableAge) { return deny(PermissionDenialReason.NotForYourAge); } allow(); });   Далее PaymentPolicyStore и BooksPolicyStore используют calcAcceptableAge для вычисления доступов:  modules/permissions/domain/stores/PermissionsStore/policies/PaymentPolicyStore  import { calcAcceptableAge } from '../../rules'; export class PaymentPolicyStore { private readonly policy: PermissionsPolicy; constructor( policyManager: PermissionsPolicyManagerStore, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policy = policyManager.createPolicy({ name: 'payment', prepareData: async () =&gt; { await Promise.all([userRepo.getPersonInfoQuery().async()]); }, }); } /** * Возможность оплатить товар */ public calcPayment = (acceptableAge: number) =&gt; this.policy.createPermission((allow, deny) =&gt; { const agePermission = calcAcceptableAge( acceptableAge, this.userRepo.getPersonInfoQuery().data?.birthday, ); if (!agePermission.isAllowed) { return deny(agePermission.reason); } allow(); }); }   modules/permissions/domain/stores/PermissionsStore/policies/BooksPolicyStore  import { calcAcceptableAge } from '../../rules'; export class BooksPolicyStore { private readonly policy: PermissionsPolicy; constructor( policyManager: PermissionsPolicyManagerStore, private readonly billingRepo: BillingRepository, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policy = policyManager.createPolicy({ name: 'books', prepareData: async () =&gt; { await Promise.all([ this.userRepo.getRolesQuery().async(), this.userRepo.getPersonInfoQuery().async(), this.billingRepo.getBillingInfoQuery().async(), ]); }, }); } /** * Возможность прочитать книгу онлайн */ public calcReadingOnline = (acceptableAge?: number) =&gt; { return this.policy.createPermission((allow, deny) =&gt; { const agePermission = calcAcceptableAge( acceptableAge, this.userRepo.getPersonInfoQuery().data?.birthday, ); if (!agePermission.isAllowed) { return deny(agePermission.reason); } const billingInfo = this.billingRepo.getBillingInfoQuery().data; if (!billingInfo?.paid) { return deny(PermissionDenialReason.NoPayAccount); } allow(); }); }; }   ","version":"Next","tagName":"h3"},{"title":"Нейминг​","type":1,"pageTitle":"Rules. Переиспользование логики доступов","url":"/guides/docs/permissions/rules#нейминг","content":" Все rules имеют префикс calc.  ✅ Valid  /** * Вычислить админские доступы */ const calcAdminPermissions = (role: string) =&gt; {...}; /** * Вычислить доступность возраста */ const calcAcceptableAge = (acceptableAge: string?, userBirthday?: string) =&gt; {...};   ❌ Invalid  const checkAdminRole = (role: string) =&gt; {...}; const checkAcceptableAge = (acceptableAge: string?, userBirthday?: string) =&gt; {...};  ","version":"Next","tagName":"h2"},{"title":"Принципы тестирования доступов","type":0,"sectionRef":"#","url":"/guides/docs/permissions/testing","content":"","keywords":"","version":"Next"},{"title":"Алгоритм покрытия Policy тестами​","type":1,"pageTitle":"Принципы тестирования доступов","url":"/guides/docs/permissions/testing#алгоритм-покрытия-policy-тестами","content":" Пример policy:  export class BooksPolicyStore { private readonly policy: PermissionsPolicy; constructor( policyManager: PolicyManagerStore, private readonly billingRepo: BillingRepository, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policy = policyManager.createPolicy({ name: 'books', prepareData: async () =&gt; { await Promise.all([ this.userRepo.getRolesQuery().async(), this.billingRepo.getBillingInfoQuery().async(), ]); }, }); } /** * Возможность добавить на полку книгу */ public get addingToShelf() { return this.policy.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } const billingInfo = this.billingRepo.getBillingInfoQuery()?.data; if (!billingInfo?.paid) { return deny(PermissionDenialReason.NoPayAccount); } if ( billingInfo.info.shelf.currentCount &gt;= billingInfo.info.shelf.allowedCount ) { return deny(PermissionDenialReason.ExceedShelfCount); } allow(); }); } }   На каждый permission, определенный в policy, необходимо писать тесты.  Для каждого permission необходимо создавать отдельный describe​  describe('AdministrationPolicyStore', () =&gt; { describe('Добавление книги на полку', () =&gt; {}); });   Для каждого permission необходимо обработать положительные и отрицательные кейсы​  Формирование кейсов происходит в соответствии с вызовом allow и deny в коде:  public get addingToShelf() { return this.policy.createPermission((allow, deny) =&gt; { // Тест-кейс: Доступно администратору if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } const billingInfo = this.billingRepo.getBillingInfoQuery()?.data; // Тест-кейс: Недоступно, если аккаунт не оплачен if (!billingInfo?.paid) { return deny(PermissionDenialReason.NoPayAccount); } // Тест-кейс: Недоступно, если превышено количество добавлений if ( billingInfo.info.shelf.currentCount &gt;= billingInfo.info.shelf.allowedCount ) { return deny(PermissionDenialReason.ExceedShelfCount); } // Тест-кейс: Доступно, если аккаунт оплачен и не превышено максимальное количество книг на полке allow(); }); }   Реализуемые тест-кейсы:  describe('BooksPolicyStore', () =&gt; { describe('Добавление книги на полку', () =&gt; { it('Доступно администратору', async () =&gt; { const { sut } = await setup({ isAdmin: true }); expect(sut.addingToShelf.isAllowed).toBeTruthy(); }); it('Недоступно, если аккаунт не оплачен', async () =&gt; {}); it('Недоступно, если превышено количество добавлений', async () =&gt; {}); it('Недоступно, если достигнуто максимальное количество добавлений', async () =&gt; {}); it('Доступно, если аккаунт оплачен и не превышено максимальное количество книг на полке', async () =&gt; {}); }); });   Перед началом выполнения теста необходимо всегда вызывать prepareData​  PolicyManagerStore поддерживает асинхронный вызов prepareData - prepareDataAsync.  describe('BooksPolicyStore', () =&gt; { const setup = async ({ isAdmin, billingInfo, }: { isAdmin: boolean; billingInfo?: Partial&lt;BillingRepositoryDTO.BillingInfo&gt;; }) =&gt; { const policyManager = createPolicyManagerStore(); const cacheService = createCacheService(); const userRepoMock = mock&lt;UserRepository&gt;({ getRolesQuery: () =&gt; cacheService.createQuery(['roles'], async () =&gt; ({ isAdmin, })), }); const billingRepoMock = mock&lt;BillingRepository&gt;({ getBillingInfoQuery: () =&gt; cacheService.createQuery(['billing'], async () =&gt; billingRepositoryFaker.makeBillingInfo(billingInfo), ), }); const sut = new BooksPolicyStore( policyManager, billingRepoMock, userRepoMock, ); await policyManager.prepareDataAsync(); return { sut }; }; describe('Добавление книги на полку', () =&gt; { it('Доступно администратору', async () =&gt; { const { sut } = await setup({ isAdmin: true }); expect(sut.addingToShelf.isAllowed).toBeTruthy(); }); }); });   Если не вызвать prepareData, то все доступы будут недоступны.  При тестировании отказа в доступе, необходимо проверять reason​  Тест-кейс Недоступно, если аккаунт не оплачен должен считаться пройденным только если reason соответствует PermissionDenialReason.NoPayAccount:  it('Недоступно, если аккаунт не оплачен', async () =&gt; { const { sut } = await setup({ isAdmin: false, billingInfo: { paid: false }, }); expect(sut.addingToShelf.isAllowed).toBeFalsy(); expect(sut.addingToShelf.reason).toBe( PermissionDenialReason.NoPayAccount, ); });   Финальный вызов allow или deny должен обрабатываться одним тест-кейсом​  public get addingToShelf() { return this.policy.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } const billingInfo = this.billingRepo.getBillingInfoQuery()?.data; if (!billingInfo?.paid) { return deny(PermissionDenialReason.NoPayAccount); } if ( billingInfo.info.shelf.currentCount &gt;= billingInfo.info.shelf.allowedCount ) { return deny(PermissionDenialReason.ExceedShelfCount); } // Этот allow будет иметь один тест-кейс allow(); }); }   Финальный вызов allow или deny должен аккумулировать условия, которые не описаны в коде:  it('Доступно, если аккаунт оплачен и не превышено максимальное количество книг на полке', async () =&gt; { const { sut } = await setup({ isAdmin: false, billingInfo: { paid: true, info: billingRepositoryFaker.makeBillingDetails({ shelf: { currentCount: 1, allowedCount: 2 }, }), }, }); expect(sut.addingToShelf.isAllowed).toBeTruthy(); });   Мотивация  Позволяет избежать роста количества тест-кейсов.  ","version":"Next","tagName":"h2"},{"title":"Тестирование Rules​","type":1,"pageTitle":"Принципы тестирования доступов","url":"/guides/docs/permissions/testing#тестирование-rules","content":" При тестировании rules необходимо:  Покрыть тестами положительные и отрицательные сценарии. Допустима группировкаПри тестировании отказа в доступе проверять reasonПоследний вызов allow или deny покрывать один тест-кейсом  export const calcAcceptableAge = ( acceptableAge?: number, userBirthday?: string, ) =&gt; createRule((allow, deny) =&gt; { if (!acceptableAge) { return deny(PermissionDenialReason.MissingData); } if (!userBirthday) { return deny(PermissionDenialReason.MissingUserAge); } if ( Math.abs(getDateYearDiff(new Date(userBirthday), new Date())) &lt; acceptableAge ) { return deny(PermissionDenialReason.NotForYourAge); } allow(); });   describe('calcAcceptableAge', () =&gt; { describe('Доступа нет', () =&gt; { it('Если нет данных о доступном возрасте', () =&gt; { const permission = calcAcceptableAge(); expect(permission.isAllowed).toBeFalsy(); expect(permission.reason).toBe(PermissionDenialReason.MissingData); }); it('Если у пользователя не заполнена дата рождения', () =&gt; {}); it('Если возраст пользователя не соответствует допустимому', () =&gt; {}); }); it('Доступ открыт, если есть доступный возраст + день рождения пользователя и возраст соответствует допустимому', () =&gt; {}); });   ","version":"Next","tagName":"h2"},{"title":"Тестирование UIStore, использующего permissions​","type":1,"pageTitle":"Принципы тестирования доступов","url":"/guides/docs/permissions/testing#тестирование-uistore-использующего-permissions","content":" Пример:  Реализованный UIStore использует permissions.books.addingToShelf. Логика формирования addingToShelf уже протестирована в permissions module, поэтому в UIStore необходимо протестировать только реакцию на разрешение и отказ в доступе:  export class UIStore { public isOpenAccountPayment = false; constructor( private readonly permissions: PermissionsStore, private readonly notifyService: Notify, ) { makeAutoObservable(this); } public addToShelf = (bookId: string) =&gt; { // Тест-кейс: Показывает информационное уведомление, если книга была успешно добавлена if (this.permissions.books.addingToShelf.isAllowed) { this.notifyService.info(`Книга ${bookId} добавлена на полку`); return; } // Тест-кейс: Открывает модалку оплаты, если было отказано в доступе с соответствующей причиной if ( this.permissions.books.addingToShelf.hasReason( PermissionDenialReason.NoPayAccount, ) ) { this.openPaymentAccount(); return; } // Тест-кейс: Показывает уведомление с ошибкой, если было превышено максимальное количество прочтений if ( this.permissions.books.addingToShelf.hasReason( PermissionDenialReason.ExceedReadingCount, ) ) { this.notifyService.error( 'Достигнуто максимальное количество книг на полке', ); return; } // Тест-кейс: Показывает уведомление с ошибкой, если было произошла непредвиденная ошибка при вычислении доступа this.notifyService.error( 'Добавить книгу на полку нельзя. Попробуйте перезагрузить страницу', ); }; public openPaymentAccount = () =&gt; { this.isOpenAccountPayment = true; }; public closePaymentAccount = () =&gt; { this.isOpenAccountPayment = false; }; }   Реализуемые тест-кейсы:  describe('GoodsListStore', () =&gt; { describe('Добавление книги на полку', () =&gt; { it('Показывает информационное уведомление, если книга была успешно добавлена', () =&gt; {}); it('Открывает модалку оплаты, если было отказано в доступе с соответствующей причиной', () =&gt; {}); it('Показывает уведомление с ошибкой, если было превышено максимальное количество прочтений', () =&gt; {}); it('Показывает уведомление с ошибкой, если было произошла непредвиденная ошибка при вычислении доступа', () =&gt; {}); }); });   ","version":"Next","tagName":"h2"},{"title":"Мок permissions​","type":1,"pageTitle":"Принципы тестирования доступов","url":"/guides/docs/permissions/testing#мок-permissions","content":" Для подмены permissions необходимо использовать mockDeep из библиотеки vitest-mock-extended и createDenialPermission из @astral/permissions:  import { mockDeep } from 'vitest-mock-extended'; import { createAllowedPermission, createDenialPermission } from '@astral/permissions'; describe('GoodsListStore', () =&gt; { describe('Добавление книги на полку', () =&gt; { const setup = (permissionsStoreMock: PermissionsStore) =&gt; { const notifyMock = mock&lt;Notify&gt;(); const sut = new UIStore(permissionsStoreMock, notifyMock); sut.addToShelf('id'); return { notifyMock, sut }; }; it('Показывает информационное уведомление, если книга была успешно добавлена', () =&gt; { // permissionsStoreMock делает addingToShelf доступным const permissionsStoreMock = mockDeep&lt;PermissionsStore&gt;({ books: { addingToShelf: createAllowedPermission(), }, }); const { notifyMock } = setup(permissionsStoreMock); expect(notifyMock.info).toBeCalledWith('Книга id добавлена на полку'); }); it('Открывает модалку оплаты, если было отказано в доступе с соответствующей причиной', () =&gt; { // permissionsStoreMock делает addingToShelf недоступным с причиной NoPayAccount const permissionsStoreMock = mockDeep&lt;PermissionsStore&gt;({ books: { addingToShelf: createDenialPermission( PermissionDenialReason.NoPayAccount, ), }, }); const { sut } = setup(permissionsStoreMock); expect(sut.isOpenAccountPayment).toBeTruthy(); }); }); });  ","version":"Next","tagName":"h3"}],"options":{"languages":["en","ru"],"id":"default"}}