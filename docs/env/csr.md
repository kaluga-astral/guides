---
sidebar_position: 3
---

# CSR. Загрузка env в runtime

## Проблема получения env в build time

Получение env в build time - это классический подход.

Работает следующим образом:
1. Сборщик при запуске получает
2. Либо помещает полученные env в `import.meta.env` (vite), либо делает replace `process.env` переменных на их значения непосредственно в js коде (webpack)
3. Переменные доступны в браузере при выполнении js

Проблемы:
- Для изменения значений env необходимо заново пересобирать приложение
- Если в приложении есть поддержка white label, то для каждого бренда необходимо собирать отдельный docker image. 
Это сильно увеличивает время сборки приложения и количество ресурсов, необходимое для поддержки и развертывания

Для решения описанных проблем необходимо использовать генерацию env при запуске docker контейнера.

## Генерация `env.js`

Для того чтобы при изменении env переменных не приходилось заново делать сборку, необходимо генерировать `env.js` файл при запуске docker контейнера и загружать его в браузер.

Для генерации `env.js` файлов используются bash скрипты.

**Почему bash?**

Bash используется по причине того, что для CSR в компании используется Nginx.
Это означает, что в итоговом docker контейнере нет nodejs, а если добавить в образ nodejs, то он вырастет в разы по объему, что повлияет на скорость сборок и оптимизацию хранилища.

## Dev Mode

### Генерация `env.js`

В режиме разработки необходимо, чтобы перед каждым запуском dev-server запускался bash скрипт, который:
1. Парсит все переменные из файла `.env.local` (или `.env.dev`)
2. Создает в директории для раздачи статики `env.js`.
Для vite - это корень приложения. Для webpack - public директория
3. Помещает в 

### Загрузка env

## Prod Mode

### Генерация `env.js`
### Загрузка env
### Подстановка переменных в nginx

## Использование env из сгенерированного файла 
