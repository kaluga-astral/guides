{"searchDocs":[{"title":"Issues","type":0,"sectionRef":"#","url":"/guides/docs/issues","content":"Issues Предложения по изменению документации или добавлению новых правил принимают либо на доске Frontend.Shared, либо через PR на Github.","keywords":"","version":"Next"},{"title":"Intro","type":0,"sectionRef":"#","url":"/guides/docs/intro","content":"Intro Архитектура и стандартные фичи, описанные в документации, должны быть использованы при проектировании frontend в Астрал-Софт.","keywords":"","version":"Next"},{"title":"Вдохновлено ABAC и XAML","type":0,"sectionRef":"#","url":"/guides/docs/permissions/core","content":"","keywords":"","version":"Next"},{"title":"На клиенте нужен ABAC, даже если на бэкенде RBAC​","type":1,"pageTitle":"Вдохновлено ABAC и XAML","url":"/guides/docs/permissions/core#на-клиенте-нужен-abac-даже-если-на-бэкенде-rbac","content":" В этой статье вы можете прочитать чем концептуально отличаются ABAC (Attribute-Based Access Control) и RBAC (Role Based Access Control).  На Frontend'е нужна такая система доступов, которая однозначно будет указывать на предмет блокировок доступов в контексте пользовательского интерфейса. RBAC и даже ABAC, имплементированный на стороне API не будет зависеть от UI, который привносит свою дополнительную специфичность при расчете доступов.  В связи с этим, на клиенте необходимо перманентно использовать ABAC, доступы которого будут напрямую связаны со специфичностью UI.  ","version":"Next","tagName":"h2"},{"title":"Пример с RBAC на бэкенде​","type":1,"pageTitle":"Вдохновлено ABAC и XAML","url":"/guides/docs/permissions/core#пример-с-rbac-на-бэкенде","content":" Предметная область  ЭДО  Роли  PaymentAccountFreeAccount  Бизнес требование  Кнопка &quot;Создать документ&quot; доступна для пользователя с платным аккаунтом и если у него есть созданная организация.  Проблема  Из требования видно, что для вычисления доступа не хватает только одного знания о роле пользователя (роль PaymentAccount), необходимо дополнительно учитывать есть у пользователя организация.  Неверное решение  Добавить к кнопке дополнительный if на проверку организации. Это приведет к &quot;размазыванию&quot; логики доступов по приложению и последующую потерю контроля.  Правильное решение  Использование ABAC с permission docActions, который внутри будет проверять роль пользователя и наличие организации.docActions будет использоваться в необходимых частях приложения для проверки доступа к действиям на документом.  ","version":"Next","tagName":"h3"},{"title":"Пример с ABAC на бэкенде​","type":1,"pageTitle":"Вдохновлено ABAC и XAML","url":"/guides/docs/permissions/core#пример-с-abac-на-бэкенде","content":" Предметная область  ЭДО  Permissions с API  docActions  Бизнес требование  Кнопка &quot;Создать документ&quot; доступна для пользователя с платным аккаунтом и если он прошел двух факторную аутентификацию.  Проблема  В docActions на бэкенде проверяется оплачен ли аккаунт пользователя, но проверку на 2FA можно провести только в runtime при нажатии на саму кнопку.  Решение  Добавить в едином клиентском сервисе доступов дополнительную логику для docActions, которая будет проверять 2FA. ","version":"Next","tagName":"h3"},{"title":"Пример реализации паттерна","type":0,"sectionRef":"#","url":"/guides/docs/permissions/example","content":"","keywords":"","version":"Next"},{"title":"Permissions Module​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#permissions-module","content":" https://github.com/kaluga-astral/vite-boilerplate/tree/main/modules/permissions  ","version":"Next","tagName":"h2"},{"title":"Policies​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#policies","content":" https://github.com/kaluga-astral/vite-boilerplate/tree/main/modules/permissions/domain/stores/PermissionsStore/policies  ","version":"Next","tagName":"h2"},{"title":"Reasons​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#reasons","content":" https://github.com/kaluga-astral/vite-boilerplate/blob/main/modules/permissions/domain/enums.ts  ","version":"Next","tagName":"h2"},{"title":"Rules​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#rules","content":" https://github.com/kaluga-astral/vite-boilerplate/tree/main/modules/permissions/domain/stores/PermissionsStore/rules  ","version":"Next","tagName":"h2"},{"title":"Использование rules​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#использование-rules","content":" https://github.com/kaluga-astral/vite-boilerplate/blob/main/modules/permissions/domain/stores/PermissionsStore/policies/PaymentPolicyStore/PaymentPolicyStore.ts#L33  ","version":"Next","tagName":"h3"},{"title":"Использование permissions в UIStore​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#использование-permissions-в-uistore","content":" https://github.com/kaluga-astral/vite-boilerplate/blob/main/modules/books/features/BookList/UIStore/UIStore.ts#L76  ","version":"Next","tagName":"h2"},{"title":"Подготовка данных​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#подготовка-данных","content":" https://github.com/kaluga-astral/vite-boilerplate/blob/main/application/app.tsx#L44  ","version":"Next","tagName":"h2"},{"title":"Route Guards​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#route-guards","content":" https://github.com/kaluga-astral/vite-boilerplate/tree/main/modules/permissions/features/routeGuards  ","version":"Next","tagName":"h2"},{"title":"Использование Route Guards​","type":1,"pageTitle":"Пример реализации паттерна","url":"/guides/docs/permissions/example#использование-route-guards","content":" admin pagebook reading page ","version":"Next","tagName":"h3"},{"title":"Feature Toggle и Permissions","type":0,"sectionRef":"#","url":"/guides/docs/permissions/featureToggle","content":"","keywords":"","version":"Next"},{"title":"Permissions может использовать Feature Toggle​","type":1,"pageTitle":"Feature Toggle и Permissions","url":"/guides/docs/permissions/featureToggle#permissions-может-использовать-feature-toggle","content":" Permissions может использовать Feature Toggle только в том случае, если Feature Toggle предоставляет Permissioning Toggles.  В противном случае Feature Toggle должен использоваться отдельно от Permissions. ","version":"Next","tagName":"h2"},{"title":"Intro","type":0,"sectionRef":"#","url":"/guides/docs/permissions/intro","content":"","keywords":"","version":"Next"},{"title":"Необходимо применять когда​","type":1,"pageTitle":"Intro","url":"/guides/docs/permissions/intro#необходимо-применять-когда","content":" В системе уже реализована какая-либо система доступов без централизованного управления на клиентеAPI предоставляет сведения о ролях. Паттерн работает в связке с ролевой модельюAPI предоставляет сведения о доступах. Паттерн расширяет на клиенте доступы, полученные из APIНа клиенте необходимо по условию (любому) закрывать доступ к части функционалаБизнес-требования описывают доступность функционала при определенных условиях (роль, сведения об оплате...)  ","version":"Next","tagName":"h2"},{"title":"Применение паттерна позволяет​","type":1,"pageTitle":"Intro","url":"/guides/docs/permissions/intro#применение-паттерна-позволяет","content":" Уменьшить затраты на разработку системы доступовИметь единую реализацию системы доступов во всех приложениях компанииЦентрализованно развивать паттернИзбежать повторения одних и тех же ошибок реализации в разных приложениях  ","version":"Next","tagName":"h2"},{"title":"Паттерн предоставляет​","type":1,"pageTitle":"Intro","url":"/guides/docs/permissions/intro#паттерн-предоставляет","content":" Удобный и поддерживаемый способ формирования доступов на клиентеСистему причин отказа в доступе. Позволяет улучшить UX и DX при работе с доступами: пользователь и разработчик получают конкретную причину отказа в доступеПодход загрузки данных для формирования доступовЗакрытие рутов приложения (RouteGuards)Взаимодействие с другими сервисами. Например, FeatureToggle  ","version":"Next","tagName":"h2"},{"title":"Готовый пакет @astral/permissions​","type":1,"pageTitle":"Intro","url":"/guides/docs/permissions/intro#готовый-пакет-astralpermissions","content":" Для более простой поддержки паттерна был реализован пакет @astral/permissions, который используется в примерах данной документации. ","version":"Next","tagName":"h2"},{"title":"2FA (Two-factor Auth)","type":0,"sectionRef":"#","url":"/guides/docs/permissions/2fa","content":"","keywords":"","version":"Next"},{"title":"Пример​","type":1,"pageTitle":"2FA (Two-factor Auth)","url":"/guides/docs/permissions/2fa#пример","content":" Требования  Создание документа доступно только администратору с активной 2FA.  Реализация  modules/permissions/domain/stores/PermissionsStore/policies/AdministrationPolicyStore  export class AdministrationPolicyStore { private readonly policy: Policy; constructor( private readonly policyManager: PolicyManagerStore, private readonly userRepo: UserRepository, private readonly twoFA: TwoFAService, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policy = this.policyManager.createPolicy({ name: 'administration', prepareData: async (): Promise&lt;void&gt; =&gt; { await Promise.all([this.userRepo.getRolesQuery().async()]); }, }); } /** * Доступ к действиям администратора */ public get administrationActions() { return this.policy.createPermission((allow, deny) =&gt; { // Если twoFA не пройдена, то отказываем в доступе с причиной, которая будет обработана в features // Также, по необходимости, можно вызвать логику запроса от пользователя прохождения 2FA if (!twoFA.isPassed) { return deny(PermissionDenialReason.TwoFA); } if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } deny(PermissionDenialReason.NoAdmin); }); } }   modules/layout/features/MainLayout/Sidebar/UIStore  export class UIStore { constructor( private readonly permissions: PermissionsStore, private readonly twoFA: TwoFAService, private readonly notifyService: Notify, private readonly router: Router, ) { makeAutoObservable(this, {}, { autoBind: true }); } public openDocCreation = () =&gt; { const permission = this.permissions.administration.administrationActions; if (permission.isAllowed) { this.router.push(APP_ROUTES.createDoc.getRedirectPath()); return; } if (permission.hasReason(PermissionDenialReason.NoAdmin)) { this.notifyService.error( 'Доступно только администратору' ); return; } if (permission.hasReason(PermissionDenialReason.TwoFA)) { // Здесь можно, например, реализовать открытие модалки для 2FA this.notifyService.error( 'Нужно пройти 2FA', ); return; } this.notifyService.error( 'Добавить документ на полку нельзя. Попробуйте сменить аккаунт', ); }; }  ","version":"Next","tagName":"h2"},{"title":"Единый Permissions Module","type":0,"sectionRef":"#","url":"/guides/docs/permissions/permissionsModule","content":"","keywords":"","version":"Next"},{"title":"Состав permissions модуля​","type":1,"pageTitle":"Единый Permissions Module","url":"/guides/docs/permissions/permissionsModule#состав-permissions-модуля","content":" Логика формирования доступовТипы доступных в приложении доступовПричины отказа в доступахЛогика блокировки рутов приложения  ","version":"Next","tagName":"h2"},{"title":"Причины концентрации логики доступов в одном модуле​","type":1,"pageTitle":"Единый Permissions Module","url":"/guides/docs/permissions/permissionsModule#причины-концентрации-логики-доступов-в-одном-модуле","content":" Контроль доступов приложения в одной точкеРасчет доступов, в большинстве случаев, связан с данными, которые необходимо получать из других модулей. Если формировать доступы на уровне конкретного модуля, то возникнет нежелательное зацепление между модулямиДоступы, мнимо относящиеся к разным модулям, будут использованы в других модулях, что также породит нежелательное зацеплениеПравила, позволяющие вычислять доступы, должны быть переиспользованы. Хранение правил в одном модуле позволит избежать зацепления модулейПричины отказа в доступе и логика для расчета доступов должна использоваться между доступами. Не централизованное хранение причин отказа и логики приведен к высокому зацеплению в системеВозможность централизованной подготовки данных для формирования базовых доступов  ","version":"Next","tagName":"h2"},{"title":"Пример с нежелательным зацеплением​","type":1,"pageTitle":"Единый Permissions Module","url":"/guides/docs/permissions/permissionsModule#пример-с-нежелательным-зацеплением","content":" Требования  Кнопка &quot;Добавить документ&quot; доступна только если есть подключенная организацияКнопка &quot;Удалить организацию&quot; доступна только если в рамках данной организации не было создано документов  Решение с зацеплением  Модуль docs реализует доступ docActions, который импортирует логику из модуля organization для проверки данных об организации. Модуль organization реализует доступ deletingOrganization, который импортирует логику из модуля docs для проверки данных о документах.  Получаем циклическую зависимость и зацепление между модулями.  Решение без зацепления  Модуль permissions содержит доступы docActions и deletingOrganization, импортируя логику из модулей docs и organization.  Модуль docs и organization теперь не зацеплены между собой. ","version":"Next","tagName":"h3"},{"title":"Reasons. Причины отказа в доступе","type":0,"sectionRef":"#","url":"/guides/docs/permissions/reasons","content":"","keywords":"","version":"Next"},{"title":"Пример использования​","type":1,"pageTitle":"Reasons. Причины отказа в доступе","url":"/guides/docs/permissions/reasons#пример-использования","content":" Требования  Пользователь не может добавить книгу на свою полку, если:  Аккаунт не оплаченПревышено доступное количество книг, которое можно добавить на полку  Если у пользователя не оплачен аккаунт, то при нажатии на кнопку &quot;Добавить на полку&quot; должна открыться модалка с предложением об оплате. Если пользователь достиг предел добавленных книг на полку, то необходимо отобразить уведомление &quot;Достигнуто максимальное количество книг на полке&quot;.  Решение  modules/permissions/domain/stores/PermissionsStore/policies/BooksPolicy  // @astral/permissions в реальном коде должен реэкспортироваться через shared import { PolicyManagerStore, Policy } from '@astral/permissions'; export class BooksPolicyStore { private readonly policy: PermissionsPolicy; constructor( policyManager: PolicyManagerStore, private readonly billingRepo: BillingRepository, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policy = policyManager.createPolicy({ name: 'books', prepareData: async () =&gt; { await Promise.all([ this.userRepo.getRolesQuery().async(), this.billingRepo.getBillingInfoQuery().async(), ]); }, }); } /** * Возможность добавить на полку книгу */ public get addingToShelf() { return this.policy.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } const billingInfo = this.billingRepo.getBillingInfoQuery()?.data; if (!billingInfo?.paid) { return deny(PermissionDenialReason.NoPayAccount); } if ( billingInfo.info.shelf.currentCount &gt;= billingInfo.info.shelf.allowedCount ) { return deny(PermissionDenialReason.ExceedShelfCount); } allow(); }); } }   modules/books/features/BookCard/UIStore  // В реальном коде для импорта из другого модуля необходимо использовать external файл import { PermissionDenialReason, PermissionsStore, permissionsStore, } from '@example/modules/permissions'; export class UIStore { public isOpenPayAccount = false; constructor( private readonly bookId: string, private readonly permissions: PermissionsStore, private readonly notifyService: Notify, ) { makeAutoObservable(this, {}, { autoBind: true }); } public addToShelf = () =&gt; { if (this.permissions.books.addingToShelf.isAllowed) { this.notifyService.info(`Книга ${this.bookId} добавлена на полку`); return; } if (this.permissions.books.addingToShelf.hasReason(PermissionDenialReason.NoPay)) { this.openPaymentAccount(); return; } if ( this.permissions.books.addingToShelf.hasReason(PermissionDenialReason.ExceedReadingCount) ) { this.notifyService.error( 'Достигнуто максимальное количество книг на полке', ); return; } this.notifyService.error( 'Добавить книгу на полку нельзя. Попробуйте перезагрузить страницу', ); }; public openPayAccount = () =&gt; { this.isOpenPayAccount = true; }; public closePayAccount = () =&gt; { this.isOpenPayAccount = false; }; } export const createUIStore = (bookId: string) =&gt; new UIStore(bookId, permissionsStore, notify);   modules/books/features/BookCard/BookCard.tsx  type Props = { id: string; }; export const BookCard = observer(({ id }: Props) =&gt; { const [{ addToShelf, isOpenPayAccount, closePayAccount }] = useState(() =&gt; createUIStore(id)); return ( &lt;&gt; &lt;Container&gt; &lt;BookInfo /&gt; &lt;Button onClick={addToShelf}&gt;Добавить на полку&lt;/Button&gt; &lt;/Container&gt; &lt;PayAccountModal isOpen={isOpenPayAccount} onClose={closePayAccount} /&gt; &lt;/&gt; ); });   ","version":"Next","tagName":"h2"},{"title":"Все reasons хранятся в одном enum​","type":1,"pageTitle":"Reasons. Причины отказа в доступе","url":"/guides/docs/permissions/reasons#все-reasons-хранятся-в-одном-enum","content":" Одни и те же причины отказа переиспользуются между разными permissions и policies.  Все reasons необходимо хранить в одном enum для того, чтобы не создавать дополнительные сложности декомпозиции при росте причин.  Reasons должны располагаться в modules/permissions/domain/enums.ts:  export enum PermissionDenialReason { /** * Не является администратором * **/ NoAdmin = 'no-admin', /** * Аккаунт не оплачен * **/ NoPayAccount = 'no-pay-account', }   Пакет @astral/permissions содержит дополнительные системные причины отказа, которые могут произойти из-за ошибок в коде:  export enum SystemDenialReason { /** * При расчете доступа произошла ошибка * **/ InternalError = 'internal-error', /** * Недостаточно данных для формирования доступа * **/ MissingData = 'missing-data', }   Для централизованного хранения reasons, необходимо объединить SystemDenialReason и reasons нашего модуля:  import { SystemDenialReason } from '@astral/permissions'; export enum PermissionsDenialReason { /** * При расчете доступа произошла ошибка * **/ InternalError = SystemDenialReason.InternalError, /** * Недостаточно данных для формирования доступа * **/ MissingData = SystemDenialReason.MissingData, /** * Пользователь не является админом * **/ NoAdmin = 'no-admin', }   ","version":"Next","tagName":"h2"},{"title":"Соглашения​","type":1,"pageTitle":"Reasons. Причины отказа в доступе","url":"/guides/docs/permissions/reasons#соглашения","content":" Для каждого reason должен быть оставлен комментарий в виде jsdoc о предназначении данного reasonЗначения reasons должны быть String в формате kebab-case ","version":"Next","tagName":"h2"},{"title":"Policies. Политики доступов","type":0,"sectionRef":"#","url":"/guides/docs/permissions/policies","content":"","keywords":"","version":"Next"},{"title":"Местоположение​","type":1,"pageTitle":"Policies. Политики доступов","url":"/guides/docs/permissions/policies#местоположение","content":" Все политики находятся в директории policies:  ├── modules/ | ├── permissions/ | | ├── stores/ | | | ├── PermissionsStore/ | | | | ├── policies/ | | | | | |── AdministrationPolicyStore/ | | | | | |── BooksPolicyStore/ | | | | | |── PaymentPolicyStore/ | | | | | └── index.ts | | | ├── PermissionsStore.ts | | | └── index.ts | | ├── enums.ts | | └── index.ts   Policies являются частью имплементации PermissionStore, поэтому находятся внутри него.  ","version":"Next","tagName":"h2"},{"title":"Создание политик​","type":1,"pageTitle":"Policies. Политики доступов","url":"/guides/docs/permissions/policies#создание-политик","content":" ","version":"Next","tagName":"h2"},{"title":"Политики напрямую связаны с модулями системы​","type":1,"pageTitle":"Policies. Политики доступов","url":"/guides/docs/permissions/policies#политики-напрямую-связаны-с-модулями-системы","content":" Modules - это предметные подобласти предметной области проекта.  Permissions внутри policies работают в рамках предметных подобласть проекта, поэтому policies должны соответствовать названию modules.  Примеры  Permission administrationActions концептуально относится к модулю administration, поэтому создается AdministrationPolicyPermission readingBook концептуально относится к модулю books, поэтому создается BooksPolicy  ","version":"Next","tagName":"h3"},{"title":"Пример создания с использованием @astral/permissions​","type":1,"pageTitle":"Policies. Политики доступов","url":"/guides/docs/permissions/policies#пример-создания-с-использованием-astralpermissions","content":" modules/permissions/domain/stores/PermissionsStore/policies/AdministrationPolicyStore  import { makeAutoObservable } from 'mobx'; import type { UserRepository } from '@example/data'; import { PermissionDenialReason } from '../../../../enums'; // @astral/permissions в реальном коде должен реэкспортироваться через shared import { PolicyManagerStore, Policy } from '@astral/permissions'; export class AdministrationPolicyStore { private readonly policy: Policy; constructor( private readonly policyManager: PolicyManagerStore, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); // policyManager.createPolicy создает политику, которая позволит в дальнейшем создавать permissions this.policy = this.policyManager.createPolicy({ name: 'administration', // Метод для подготовки данных необходимых для формирования доступов AdministrationPolicy prepareData: async (): Promise&lt;void&gt; =&gt; { await Promise.all([this.userRepo.getRolesQuery().async()]); }, }); } }   ","version":"Next","tagName":"h3"},{"title":"Доступ к политикам через единую точку PermissionsStore​","type":1,"pageTitle":"Policies. Политики доступов","url":"/guides/docs/permissions/policies#доступ-к-политикам-через-единую-точку-permissionsstore","content":" PermissionsStore - это singleton и единая входная точка в приложении для получения информации о доступах.  Другие модули приложения взаимодействуют именно с PermissionStore.  Пример реализации:  import { makeAutoObservable } from 'mobx'; import { billingRepository, userRepository } from '@example/data'; import type { BillingRepository, UserRepository } from '@example/data'; // В реальном коде @astral/permissions необходимо реэкспортировать через shared import type { PolicyManagerStore } from '@astral/permissions'; import { createPolicyManagerStore } from '@astral/permissions'; import { createAdministrationPolicyStore, createBooksPolicyStore, createPaymentPolicyStore, } from './policies'; import type { AdministrationPolicyStore, BooksPolicyStore, PaymentPolicyStore, } from './policies'; /** * Содержит все доступы приложения */ export class PermissionsStore { private readonly policyManager: PolicyManagerStore; public readonly administration: AdministrationPolicyStore; public readonly books: BooksPolicyStore; constructor(billingRepo: BillingRepository, userRepo: UserRepository) { makeAutoObservable(this, {}, { autoBind: true }); // policyManager регистрирует все доступы и позволяет подготовить данные для формирования доступов this.policyManager = createPolicyManagerStore(); this.administration = createAdministrationPolicyStore( this.policyManager, userRepo, ); this.books = createBooksPolicyStore( this.policyManager, billingRepo, userRepo, ); } /** * Подготавливает данные для формирования доступов */ public prepareData = () =&gt; this.policyManager.prepareDataSync(); public get preparingDataStatus() { return this.policyManager.preparingDataStatus; } } // singleton export const permissionsStore = new PermissionsStore( billingRepository, userRepository, );   Пример использования:  export class UIStore { constructor(private readonly permissions: PermissionsStore) { makeAutoObservable(this, {}, { autoBind: true }); } public get isAllowedBookCreation() { return this.permissions.administration.administrationActions.isAllowed; } }   Мотивация  Возможность централизованной подготовки данных для формирования permissionsВозможность реализации логирования для дебагингаУвеличение DX за счет отказа от необходимо импорта разных policies  ","version":"Next","tagName":"h2"},{"title":"Переиспользование логики между policies​","type":1,"pageTitle":"Policies. Политики доступов","url":"/guides/docs/permissions/policies#переиспользование-логики-между-policies","content":" Policies не должны зависеть друг от друга и соответственно переиспользовать permissions потому.  Переиспользование permissions между policies приводит к пересечению бизнес требований и запутанной логике формирования доступов.  Если между policies необходимо переиспользовать логику, то надо использовать rules. ","version":"Next","tagName":"h2"},{"title":"Формирование доступов","type":0,"sectionRef":"#","url":"/guides/docs/permissions/permissionsFormation","content":"","keywords":"","version":"Next"},{"title":"Как выделять permission​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#как-выделять-permission","content":" Требование является permission, если:  Требование указывает на то, что функционал приложения должен быть ограничен на основе данных об аккаунте (роль, организация, оплата...)Описанное ограничение может быть снято при изменении данных пользователя  Permission не является:  Временный Feature Toggle на функционалПерманентное условие на блокировку функционала, без возможности открытия доступа (даже при изменении роли пользователя)Условия (if) в коде, реализующие рядовые бизнес требования  ","version":"Next","tagName":"h2"},{"title":"Примеры требований​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#примеры-требований","content":" Кнопка &quot;Создать документ&quot; доступна только администратору - это permission потому, что ограничение основывается на данных пользователя и доступ к функционалу можно открыть, если изменить роль пользователя.  Кнопка &quot;Редактировать документ&quot; доступна только для пользователей с платным аккаунтом и добавленной организацией - это permission потому, что ограничение основывается на данных пользователя и доступ к функционалу можно открыть, если оплатить аккаунт и добавить организацию.  Кнопка &quot;Создать документ&quot; заблокирована до 20.05.2024 - это не permission, а feature toggle. Требование не зависит от данных пользователя.  При этом:  Кнопка &quot;Создать документ&quot; для пользователей с тарифом &quot;Базовый&quot; заблокирована до 20.05.2024 - это уже permission потому, что основывается на данных пользователя.  Кнопка &quot;Отправить&quot; заблокирована, если чекбокс &quot;Ознакомлен с требованиями&quot; не активен - это не permission. Это требование для формы.  ","version":"Next","tagName":"h3"},{"title":"Создание permissions посредством @astral/permissions​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#создание-permissions-посредством-astralpermissions","content":" Permissions создаются только внутри policy с помощью метода policy.createPermission:  modules/permissions/domain/stores/PermissionsStore/policies/AdministrationPolicyStore  import { makeAutoObservable } from 'mobx'; import type { UserRepository } from '@example/data'; import { PermissionDenialReason } from '../../../../enums'; // @astral/permissions в реальном коде должен реэкспортироваться через shared import { PolicyManagerStore, Policy } from '@astral/permissions'; export class AdministrationPolicyStore { private readonly policy: Policy; constructor( private readonly policyManager: PolicyManagerStore, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policy = this.policyManager.createPolicy({ name: 'administration', prepareData: async (): Promise&lt;void&gt; =&gt; { await Promise.all([this.userRepo.getRolesQuery().async()]); }, }); } /** * Доступ к действиям администратора */ public get administrationActions() { return this.policy.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { // разрешает доступ return allow(); } // запрещает доступ с конкретной причиной deny(PermissionDenialReason.NoAdmin); }); } }   ","version":"Next","tagName":"h2"},{"title":"API Permission​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#api-permission","content":" createPermission возвращает объект вида:  type Permission = { isAllowed: boolean; /** * Причина отказа в доступе */ reason?: string; /** * @example permission.hasReason(DenialReason.NoAdmin) */ hasReason: (reason: string) =&gt; boolean; };   О причинах отказа читайте далее.  ","version":"Next","tagName":"h3"},{"title":"Пример реализации и использования permission​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#пример-реализации-и-использования-permission","content":" Требования  Кнопка &quot;Создать книгу&quot; в Sidebar отображается только если пользователь является администратором.  Решение  modules/permissions/domain/stores/PermissionsStore/policies/AdministrationPolicyStore  class AdministrationPolicyStore { constructor( private readonly policyManager: PolicyManagerStore, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policyManager.createPolicy({ name: 'administration', prepareData: async (): Promise&lt;void&gt; =&gt; { await Promise.all([this.userRepo.getRolesQuery().async()]); }, }); } /** * Доступ к действиям администратора */ public get administrationActions() { return this.policyManager.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } deny(PermissionDenialReason.NoAdmin); }); } }   В features необходимо избегать разрешения доступов через абстрактные компоненты вида:  import { observer } from 'mobx-react-lite'; import { permissionsStore } from '@example/modules/permissions'; export const Sidebar = observer(() =&gt; { return ( &lt;Sidebar&gt; &lt;PermissionsGateway permission={permissionsStore.administration.administrationActions} allow={ &lt;RouterLink to={APP_ROUTES.createBook.getRedirectPath()}&gt; Создать книгу &lt;/RouterLink&gt; } /&gt; &lt;/Sidebar&gt; ); });   Использование компонентов вроде PermissionsGateway переносит логику доступов для фичи в UI слой, что нарушает архитектурную концепцию.  Разрешение доступов должно происходить в UIStore:  modules/layout/features/MainLayout/Sidebar/UIStore  export class UIStore { constructor(private readonly permissions: PermissionsStore) { makeAutoObservable(this, {}, { autoBind: true }); } public get isAllowedBookCreation() { return this.permissions.administration.administrationActions.isAllowed; } }   modules/layout/features/MainLayout/Sidebar/Sidebar.tsx  export const Sidebar = observer(() =&gt; { const [{ isAllowedBookCreation }] = useState(createUIStore); return ( &lt;Sidebar&gt; &lt;SidebarItem&gt; {isAllowedBookCreation &amp;&amp; ( &lt;RouterLink to={APP_ROUTES.createBook.getRedirectPath()}&gt; Создать книгу &lt;/RouterLink&gt; )} &lt;/SidebarItem&gt; &lt;/Sidebar&gt; ); });   ","version":"Next","tagName":"h2"},{"title":"Permission не должен зависеть от UI​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#permission-не-должен-зависеть-от-ui","content":" Permission не должен напрямую зависеть и указывать на UI, который блокируется. Зависимость от UI приведет к взрывному росту permissions и в последствии к сложной поддержке кода.  ","version":"Next","tagName":"h2"},{"title":"Пример​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#пример","content":" Кнопка &quot;Создать документ&quot; отображается только если пользователь является администратором - в данном требовании присутствует указать на конкретную кнопку.  Неправильное решение​  Создать permission showCreationDocButton:  class AdministrationPolicyStore { ... public get showCreationDocButton() { return this.policyManager.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } deny(PermissionDenialReason.NoAdmin); }); } public get allowAdministrationRoute() { return this.policyManager.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } deny(PermissionDenialReason.NoAdmin); }); } public get showEditingDocModal() { return this.policyManager.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } deny(PermissionDenialReason.NoAdmin); }); } }   Как видно из примера, при связывании permission и UI происходит взрывной рост одинаковых доступов:  Доступ к кнопкеДоступ к рутуДоступ к модалке редактирования  Правильное решение​  Создать абстрактный permission administrationActions, который будет закрывать доступ к действиям администратора:  class AdministrationPolicyStore { ... public get administrationActions() { return this.policyManager.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } deny(PermissionDenialReason.NoAdmin); }); } }   Теперь на уровне features необходимо проверять administrationActions и на основе его выполнять необходимые действия.  ","version":"Next","tagName":"h3"},{"title":"Нейминг​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#нейминг","content":" Название permission должно отвечать на вопрос: &quot;Доступ открыт/закрыт для чего/к чему?&quot;.  Примеры  Доступ закрыт к действиям администратора - administrationActionsДоступ закрыт к чтению книги онлайн - readingBookДоступ закрыт к управлению организацией - organizationManagement  ✅ Valid  public get administrationActions() { ... } public get addingToShelf() { ... } public get readingBook() { ... } public get organizationManagement() { ... }   ❌ Invalid  public get canReadingBook() { ... } public get isAddToShelf() { ... }   ","version":"Next","tagName":"h2"},{"title":"Нейминг методов для вычисления доступов​","type":1,"pageTitle":"Формирование доступов","url":"/guides/docs/permissions/permissionsFormation#нейминг-методов-для-вычисления-доступов","content":" Для методов, которые вычисляют доступы, добавляется префикс calc.  ✅ Valid  public calcReadingBook = (bookId: string) =&gt; { ... }   ❌ Invalid  public checkReadingBook = (bookId: string) =&gt; { ... }  ","version":"Next","tagName":"h3"},{"title":"Rules. Переиспользование логики доступов","type":0,"sectionRef":"#","url":"/guides/docs/permissions/rules","content":"","keywords":"","version":"Next"},{"title":"Местоположение​","type":1,"pageTitle":"Rules. Переиспользование логики доступов","url":"/guides/docs/permissions/rules#местоположение","content":" Все правила находятся в директории rules:  ├── modules/ | ├── permissions/ | | ├── stores/ | | | ├── PermissionsStore/ | | | | ├── policies/ | | | | ├── rules/ | | | | | |── calcAcceptableAge/ | | | | | |── calcAccountPayment/ | | | | | └── index.ts | | | ├── PermissionsStore.ts | | | └── index.ts | | ├── enums.ts | | └── index.ts   ","version":"Next","tagName":"h2"},{"title":"Rules - приватные функции модуля permissions​","type":1,"pageTitle":"Rules. Переиспользование логики доступов","url":"/guides/docs/permissions/rules#rules---приватные-функции-модуля-permissions","content":" Rules недоступны вне permissions модуля и являются частью имплементации PermissionsStore.  ","version":"Next","tagName":"h2"},{"title":"Реализация rules​","type":1,"pageTitle":"Rules. Переиспользование логики доступов","url":"/guides/docs/permissions/rules#реализация-rules","content":" Rules создаются с помощью createRule из пакета @astral/permissions:  ","version":"Next","tagName":"h2"},{"title":"Пример​","type":1,"pageTitle":"Rules. Переиспользование логики доступов","url":"/guides/docs/permissions/rules#пример","content":" Требования  Чтение книги доступно только если возраст пользователя соответствует доступному возрасту, указанному в книгеПокупка товара доступна только если возраст пользователя соответствует доступному возрасту, указанному в товаре  Решение  Требуется реализовать два permissions: calcReadingBook и calcPayment. Оба permissions должны реализовать одну и ту же логику проверки возраста пользователя. Необходимо реализовать rule: calcAcceptableAge:  modules/permissions/domain/stores/PermissionsStore/rules/calcAcceptableAge  // @astral/permissions в реальном коде необходимо реэкспортировать через shared import { createRule } from '@astral/permissions'; export const calcAcceptableAge = ( acceptableAge?: number, userBirthday?: string, ) =&gt; createRule((allow, deny) =&gt; { if (!acceptableAge) { return deny(PermissionDenialReason.MissingData); } if (!userBirthday) { return deny(PermissionDenialReason.MissingUserAge); } if (getDateYearDiff(new Date(userBirthday), new Date()) &lt; acceptableAge) { return deny(PermissionDenialReason.NotForYourAge); } allow(); });   Далее PaymentPolicyStore и BooksPolicyStore используют calcAcceptableAge для вычисления доступов:  modules/permissions/domain/stores/PermissionsStore/policies/PaymentPolicyStore  import { calcAcceptableAge } from '../../rules'; export class PaymentPolicyStore { private readonly policy: PermissionsPolicy; constructor( policyManager: PermissionsPolicyManagerStore, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policy = policyManager.createPolicy({ name: 'payment', prepareData: async () =&gt; { await Promise.all([userRepo.getPersonInfoQuery().async()]); }, }); } /** * Возможность оплатить товар */ public calcPayment = (acceptableAge: number) =&gt; this.policy.createPermission((allow, deny) =&gt; { const agePermission = calcAcceptableAge( acceptableAge, this.userRepo.getPersonInfoQuery().data?.birthday, ); if (!agePermission.isAllowed) { return deny(agePermission.reason); } allow(); }); }   modules/permissions/domain/stores/PermissionsStore/policies/BooksPolicyStore  import { calcAcceptableAge } from '../../rules'; export class BooksPolicyStore { private readonly policy: PermissionsPolicy; constructor( policyManager: PermissionsPolicyManagerStore, private readonly billingRepo: BillingRepository, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policy = policyManager.createPolicy({ name: 'books', prepareData: async () =&gt; { await Promise.all([ this.userRepo.getRolesQuery().async(), this.userRepo.getPersonInfoQuery().async(), this.billingRepo.getBillingInfoQuery().async(), ]); }, }); } /** * Возможность прочитать книгу онлайн */ public calcReadingOnline = (acceptableAge?: number) =&gt; { return this.policy.createPermission((allow, deny) =&gt; { const agePermission = calcAcceptableAge( acceptableAge, this.userRepo.getPersonInfoQuery().data?.birthday, ); if (!agePermission.isAllowed) { return deny(agePermission.reason); } const billingInfo = this.billingRepo.getBillingInfoQuery().data; if (!billingInfo?.paid) { return deny(PermissionDenialReason.NoPayAccount); } allow(); }); }; }   ","version":"Next","tagName":"h3"},{"title":"Нейминг​","type":1,"pageTitle":"Rules. Переиспользование логики доступов","url":"/guides/docs/permissions/rules#нейминг","content":" Все rules имеют префикс calc.  ✅ Valid  /** * Вычислить админские доступы */ const calcAdminPermissions = (role: string) =&gt; {...}; /** * Вычислить доступность возраста */ const calcAcceptableAge = (acceptableAge: string?, userBirthday?: string) =&gt; {...};   ❌ Invalid  const checkAdminRole = (role: string) =&gt; {...}; const checkAcceptableAge = (acceptableAge: string?, userBirthday?: string) =&gt; {...};  ","version":"Next","tagName":"h2"},{"title":"Подготовка данных для доступов","type":0,"sectionRef":"#","url":"/guides/docs/permissions/preparingData","content":"","keywords":"","version":"Next"},{"title":"Каждая policy указывает какие данные нужны для доступов​","type":1,"pageTitle":"Подготовка данных для доступов","url":"/guides/docs/permissions/preparingData#каждая-policy-указывает-какие-данные-нужны-для-доступов","content":" Каждая policy определяет метод подготовки данных, которые нужны для формирования запросов.  ","version":"Next","tagName":"h2"},{"title":"Пример​","type":1,"pageTitle":"Подготовка данных для доступов","url":"/guides/docs/permissions/preparingData#пример","content":" В BooksPolicy для формирования доступа addingToShelf требуются данные из UserRepository и BillingRepository.  При создании policy необходимо указать как получить эти данные:  // @astral/permissions в реальном коде должен реэкспортироваться через shared import { PolicyManagerStore, Policy } from '@astral/permissions'; export class BooksPolicyStore { private readonly policy: PermissionsPolicy; constructor( policyManager: PolicyManagerStore, private readonly billingRepo: BillingRepository, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policy = policyManager.createPolicy({ name: 'books', // prepareData будет вызван одновременно с другими policy посредством policyManager prepareData: async () =&gt; { await Promise.all([ this.userRepo.getRolesQuery().async(), this.userRepo.getPersonInfoQuery().async(), this.billingRepo.getBillingInfoQuery().async(), ]); }, }); } /** * Возможность добавить на полку книгу */ public get addingToShelf() { return this.policy.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } const billingInfo = this.billingRepo.getBillingInfoQuery()?.data; if (!billingInfo?.paid) { return deny(PermissionDenialReason.NoPayAccount); } if ( billingInfo.info.shelf.currentCount &gt;= billingInfo.info.shelf.allowedCount ) { return deny(PermissionDenialReason.ExceedShelfCount); } allow(); }); } }   ","version":"Next","tagName":"h3"},{"title":"PermissionsStore.prepareData подготовит данные для всех policy​","type":1,"pageTitle":"Подготовка данных для доступов","url":"/guides/docs/permissions/preparingData#permissionsstorepreparedata-подготовит-данные-для-всех-policy","content":" PermissionsStore должен иметь метод prepareData, который вызовет подготовку данных в каждом policy:  // В реальном коде @astral/permissions необходимо реэкспортировать через shared import type { PolicyManagerStore } from '@astral/permissions'; import { createPolicyManagerStore } from '@astral/permissions'; /** * Содержит все доступы приложения */ export class PermissionsStore { private readonly policyManager: PolicyManagerStore; public readonly administration: AdministrationPolicyStore; public readonly books: BooksPolicyStore; constructor(billingRepo: BillingRepository, userRepo: UserRepository) { makeAutoObservable(this, {}, { autoBind: true }); // policyManager регистрирует все доступы и позволяет подготовить данные для формирования доступов this.policyManager = createPolicyManagerStore(); this.administration = createAdministrationPolicyStore( this.policyManager, userRepo, ); this.books = createBooksPolicyStore( this.policyManager, billingRepo, userRepo, ); } /** * Подготавливает данные для формирования доступов */ public prepareData = () =&gt; this.policyManager.prepareDataSync(); public get preparingDataStatus() { return this.policyManager.preparingDataStatus; } }   За подготовку данных отвечает PolicyManagerStore. PolicyManagerStore регистрирует для каждого policy метод подготовки prepareDataи при вызове policyManager.prepareData запускает вызов каждой prepareData каждого policy  Мотивация использования единого метода подготовки данных  Выбран подход использования единого метода для загрузки данных для того, чтобы соблюдать баланс между сложностью использования и оптимизацией загрузки данных:  Если вызывать для каждой policy или для каждого permission отдельный метод загрузки данных, то все фичи приложения, использующие доступы, должны будут быть обернуты в ContentStateНеобходимо следить за запросами, которые вызываются в методах подготовки данных - они не должны быть медленными потому, что блокируют рендеринг приложения  ","version":"Next","tagName":"h2"},{"title":"Использование​","type":1,"pageTitle":"Подготовка данных для доступов","url":"/guides/docs/permissions/preparingData#использование","content":" PermissionsStore.prepareData необходимо вызывать в application слое приложения:  application/app.tsx   export const App = observer(() =&gt; { const renderRoutes = useRoutes(routes); const permissionsStatus = permissionsStore.preparingDataStatus; useEffect(() =&gt; { permissionsStore.prepareData(); authStore.addProtectedHttpClients([apiHttpClient]); }, []); return ( &lt;ThemeProvider theme={theme}&gt; &lt;NotificationContainer /&gt; &lt;ContentState isError={permissionsStatus.isError} isLoading={permissionsStatus.isLoading} errorState={{ errorList: [permissionsStatus.error], onRetry: permissionsStore.prepareData, }} &gt; &lt;MainLayout&gt;{renderRoutes}&lt;/MainLayout&gt; &lt;/ContentState&gt; &lt;/ThemeProvider&gt; ); });   Не рекомендуется рендерить приложение, пока данные для permissions не будут успешно подготовлены.  ","version":"Next","tagName":"h3"},{"title":"Оптимизация PermissionsStore.prepareData​","type":1,"pageTitle":"Подготовка данных для доступов","url":"/guides/docs/permissions/preparingData#оптимизация-permissionsstorepreparedata","content":" Необходимо следить за запросами, которые вызываются в методах подготовки данных - они не должны быть медленными потому, что блокируют рендеринг приложения.  Запросы могут использоваться в prepareData, если:  Запрашиваемые данные нужны для рендеринга приложения не только в PermissionsStoreЗапрашиваемые данные значительно не влияют на блокировку рендера приложения  Если запросы являются не оптимальными для использования в PermissionsStore, то для формирования permissions необходимо использовать методы, принимающие на вход данные:  import { calcAcceptableAge } from '../../rules'; export class PaymentPolicyStore { private readonly policy: PermissionsPolicy; constructor( policyManager: PermissionsPolicyManagerStore, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policy = policyManager.createPolicy({ name: 'payment', prepareData: async () =&gt; { await Promise.all([userRepo.getPersonInfoQuery().async()]); }, }); } /** * Возможность оплатить товар */ public calcPayment = (acceptableAge: number) =&gt; this.policy.createPermission((allow, deny) =&gt; { const agePermission = calcAcceptableAge( acceptableAge, this.userRepo.getPersonInfoQuery().data?.birthday, ); if (!agePermission.isAllowed) { return deny(agePermission.reason); } allow(); }); }   В таком случае за получение данных будет ответственна та часть приложения, которая будет использовать permission:  modules/books/features/BookCard/UIStore  export class UIStore { public isOpenPayAccount = false; constructor( private readonly bookId: string, private readonly permissions: PermissionsStore, private readonly notifyService: Notify, private readonly booksRepo: BooksRepository ) { makeAutoObservable(this, {}, { autoBind: true }); } private get bookByIdQuery() { return this.booksRepo.getBookByIdQuery(this.bookId); } public buy = () =&gt; { const payPermission = this.permissions.calcPayment(this.bookByIdQuery.acceptableAge); if (payPermission.isAllowed) { this.notifyService.success(`Книга ${bookId} оплачена`); return; } if (payPermission.hasReason(PermissionDenialReason.NotAcceptAge)) { this.notifyService.error('Вы слишком молоды'); return; } this.notifyService.error( 'Купить книгу нельзя. Попробуйте перезагрузить страницу', ); }; public openPayAccount = () =&gt; { this.isOpenPayAccount = true; }; public closePayAccount = () =&gt; { this.isOpenPayAccount = false; }; }   ","version":"Next","tagName":"h2"},{"title":"Обработка проблем получения данных​","type":1,"pageTitle":"Подготовка данных для доступов","url":"/guides/docs/permissions/preparingData#обработка-проблем-получения-данных","content":" Если перед использованием permissions в features, не были успешно загружены данные, то permissions будут возвращать объект с конкретным reason:  type DenialMissingDataPermission = { isAllowed: false; reason: PermissionDenialReason.MissingData; };   Reason PermissionDenialReason.MissingData можно будет при необходимости обработать централизованно или на месте использования permissions. ","version":"Next","tagName":"h2"},{"title":"Route Guards. Доступы к рутам приложения","type":0,"sectionRef":"#","url":"/guides/docs/permissions/routes","content":"","keywords":"","version":"Next"},{"title":"Местоположение​","type":1,"pageTitle":"Route Guards. Доступы к рутам приложения","url":"/guides/docs/permissions/routes#местоположение","content":" Все Route Guards хранятся в modules/permissions/features/routeGuards:  ├── modules/ | ├── permissions/ | | ├── features/ | | | ├── routesGuards/ | | | | ├── AdminRouteGuard/ | | | | ├── ReadingBookRouteGuard/ | | | | └── index.ts | | | └── index.ts | | └── index.ts   ","version":"Next","tagName":"h2"},{"title":"Guard вызывается для каждой page​","type":1,"pageTitle":"Route Guards. Доступы к рутам приложения","url":"/guides/docs/permissions/routes#guard-вызывается-для-каждой-page","content":" Route Guard должен вызываться на каждой page, которая должна быть защищена доступами.  МотивацияВызов Route Guard для каждого page позволяет достичь простоты поддержки. При исследовании pages сразу видна связь страницы и доступов.  Использование конфигурации с описанием доступных рутов в модуле permissions значительно усложняет понимание кода и простоту поддержки функционала.  ","version":"Next","tagName":"h2"},{"title":"Пример​","type":1,"pageTitle":"Route Guards. Доступы к рутам приложения","url":"/guides/docs/permissions/routes#пример","content":" Необходимо закрыть pages:  admin/createBookbook/reading  ├── application/ | ├── pages/ | | ├── admin/ | | | ├── createBook.tsx | | ├── book/ | | | ├── reading.tsx ├── modules/ | ├── permissions/ | | ├── features/ | | | ├── routesGuards/ | | | | ├── AdminRouteGuard/ | | | | ├── ReadingBookRouteGuard/ | | | | └── index.ts | | | └── index.ts | | └── index.ts   application/pages/admin/createBook.tsx  import { CreationBookScreen } from '@example/screens'; import { AdminRouteGuard } from '@example/modules/permissions'; const CreateBookPage = () =&gt; { return ( &lt;AdminRouteGuard&gt; &lt;CreationBookScreen /&gt; &lt;/AdminRouteGuard&gt; ); }; export default CreateBookPage;   application/pages/book/reading.tsx  import { NotFoundScreen, ReadingBookScreen } from '@example/screens'; import { useRouterParams } from '@example/shared'; import { ReadingBookRouteGuard } from '@example/modules/permissions'; const ReadingBookPage = () =&gt; { const { id } = useRouterParams(); if (!id) { return &lt;NotFoundScreen title=&quot;Книга не найдена&quot; /&gt;; } return ( &lt;ReadingBookRouteGuard id={id}&gt; &lt;ReadingBookScreen id={id} /&gt; &lt;/ReadingBookRouteGuard&gt; ); }; export default ReadingBookPage;   ","version":"Next","tagName":"h3"},{"title":"Вложенные страницы​","type":1,"pageTitle":"Route Guards. Доступы к рутам приложения","url":"/guides/docs/permissions/routes#вложенные-страницы","content":" Использование Route Guard для каждой страницы создает небольшой overhead: для каждой вложенной страницы необходимо вызывать Route Guard, возможности закрыть всю вложенность нет.  Данное ограничение принимается в угоду более простой поддержки.  ","version":"Next","tagName":"h3"},{"title":"Создание Route Guard​","type":1,"pageTitle":"Route Guards. Доступы к рутам приложения","url":"/guides/docs/permissions/routes#создание-route-guard","content":" В modules/permissions/features/routeGuards необходимо создать Route Guard, который будет закрывать конкретную страницу или ряд страниц. Реализация зависит от требований.  Все Route Guard создаются на основе абстрактного PermissionRouteGuard.  PermissionRouteGuard - фасад, позволяющий упростить реализацию Route Guards и обработать стандартные причины отказа.  ","version":"Next","tagName":"h2"},{"title":"Пример​","type":1,"pageTitle":"Route Guards. Доступы к рутам приложения","url":"/guides/docs/permissions/routes#пример-1","content":" Требования  Страница создания книги (admin/createBook) должна быть доступна только администратору.  Реализация  В AdministrationPolicy уже реализован permissions - administrationActions, на основе которого можно делать вывод доступна ли пользователю страница создания книги.  На момент реализации, все вложенные руты в /admin подходят под administrationActions permission, поэтому реализуем единый для всех /admin/ Guard:  modules/permissions/features/routeGuards/AdminRouteGuard  import type { ReactNode } from 'react'; import { observer } from 'mobx-react-lite'; import { PageLayout, Placeholder } from '@example/shared'; import { PermissionDenialReason, permissionsStore } from '../../../domain'; import { PermissionGuard } from '../../PermissionGuard'; type Props = { children: ReactNode; }; export const AdminRouteGuard = observer(({ children }: Props) =&gt; { return ( &lt;PermissionGuard permission={permissionsStore.administration.administrationActions} denialSwitch={{ [PermissionDenialReason.NoAdmin]: ( &lt;PageLayout header={{ title: 'Панель администратора' }} content={{ children: ( &lt;Placeholder title=&quot;Доступно только для администраторов&quot; /&gt; ), }} /&gt; ), }} &gt; {children} &lt;/PermissionGuard&gt; ); });   denialSwitch позволяет обработать причины отказа. В данном случае, если причина отказа 'no-admin', то необходимо показать соответствующий Placeholder.  Закрывает требуемую страницу приложения:  application/pages/admin/createBook.tsx  import { CreationBookScreen } from '@example/screens'; import { AdminRouteGuard } from '@example/modules/permissions'; const CreateBookPage = () =&gt; { return ( &lt;AdminRouteGuard&gt; &lt;CreationBookScreen /&gt; &lt;/AdminRouteGuard&gt; ); }; export default CreateBookPage;   ","version":"Next","tagName":"h3"},{"title":"Обработка дефолтных причин отказа в доступе​","type":1,"pageTitle":"Route Guards. Доступы к рутам приложения","url":"/guides/docs/permissions/routes#обработка-дефолтных-причин-отказа-в-доступе","content":" В PermissionRouteGuard можно обработать дефолтные причины для отказа.  ","version":"Next","tagName":"h2"},{"title":"Пример​","type":1,"pageTitle":"Route Guards. Доступы к рутам приложения","url":"/guides/docs/permissions/routes#пример-2","content":" import { Placeholder } from '@example/shared'; import type { Permission } from '../../domain'; import { PermissionDenialReason } from '../../domain'; type Props = { permission: Permission; /** * Позволяет отрендерить компонент для конкретной причины отказа в доступе */ denialSwitch: Record&lt;string, ReactNode&gt;; children: ReactNode; }; /** * Закрывает доступ к children, обрабатывает дефолтные причины отказа */ export const PermissionGuard = ({ permission, denialSwitch, children, }: Props) =&gt; { if (permission.isAllowed) { return children; } if (denialSwitch[permission.reason]) { return denialSwitch[permission.reason]; } if (permission.reason === PermissionDenialReason.NoPayAccount) { return &lt;Placeholder title=&quot;Необходимо оплатить аккаунт&quot; /&gt;; } if (permission.reason === PermissionDenialReason.MissingUserAge) { return &lt;Placeholder title=&quot;Необходимо заполнить дату рождения в ЛК&quot; /&gt;; } return &lt;Placeholder title=&quot;Нет доступа&quot; /&gt;; };  ","version":"Next","tagName":"h3"},{"title":"Принципы тестирования доступов","type":0,"sectionRef":"#","url":"/guides/docs/permissions/testing","content":"","keywords":"","version":"Next"},{"title":"Алгоритм покрытия Policy тестами​","type":1,"pageTitle":"Принципы тестирования доступов","url":"/guides/docs/permissions/testing#алгоритм-покрытия-policy-тестами","content":" Пример policy:  export class BooksPolicyStore { private readonly policy: PermissionsPolicy; constructor( policyManager: PolicyManagerStore, private readonly billingRepo: BillingRepository, private readonly userRepo: UserRepository, ) { makeAutoObservable(this, {}, { autoBind: true }); this.policy = policyManager.createPolicy({ name: 'books', prepareData: async () =&gt; { await Promise.all([ this.userRepo.getRolesQuery().async(), this.billingRepo.getBillingInfoQuery().async(), ]); }, }); } /** * Возможность добавить на полку книгу */ public get addingToShelf() { return this.policy.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } const billingInfo = this.billingRepo.getBillingInfoQuery()?.data; if (!billingInfo?.paid) { return deny(PermissionDenialReason.NoPayAccount); } if ( billingInfo.info.shelf.currentCount &gt;= billingInfo.info.shelf.allowedCount ) { return deny(PermissionDenialReason.ExceedShelfCount); } allow(); }); } }   На каждый permission, определенный в policy, необходимо писать тесты.  Для каждого permission необходимо создавать отдельный describe​  describe('AdministrationPolicyStore', () =&gt; { describe('Добавление книги на полку', () =&gt; {}); });   Для каждого permission необходимо обработать положительные и отрицательные кейсы​  Формирование кейсов происходит в соответствии с вызовом allow и deny в коде:  public get addingToShelf() { return this.policy.createPermission((allow, deny) =&gt; { // Тест-кейс: Доступно администратору if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } const billingInfo = this.billingRepo.getBillingInfoQuery()?.data; // Тест-кейс: Недоступно, если аккаунт не оплачен if (!billingInfo?.paid) { return deny(PermissionDenialReason.NoPayAccount); } // Тест-кейс: Недоступно, если превышено количество добавлений if ( billingInfo.info.shelf.currentCount &gt;= billingInfo.info.shelf.allowedCount ) { return deny(PermissionDenialReason.ExceedShelfCount); } // Тест-кейс: Доступно, если аккаунт оплачен и не превышено максимальное количество книг на полке allow(); }); }   Реализуемые тест-кейсы:  describe('BooksPolicyStore', () =&gt; { describe('Добавление книги на полку', () =&gt; { it('Доступно администратору', async () =&gt; { const { sut } = await setup({ isAdmin: true }); expect(sut.addingToShelf.isAllowed).toBeTruthy(); }); it('Недоступно, если аккаунт не оплачен', async () =&gt; {}); it('Недоступно, если превышено количество добавлений', async () =&gt; {}); it('Недоступно, если достигнуто максимальное количество добавлений', async () =&gt; {}); it('Доступно, если аккаунт оплачен и не превышено максимальное количество книг на полке', async () =&gt; {}); }); });   Перед началом выполнения теста необходимо всегда вызывать prepareData​  PolicyManagerStore поддерживает асинхронный вызов prepareData - prepareDataAsync.  describe('BooksPolicyStore', () =&gt; { const setup = async ({ isAdmin, billingInfo, }: { isAdmin: boolean; billingInfo?: Partial&lt;BillingRepositoryDTO.BillingInfo&gt;; }) =&gt; { const policyManager = createPolicyManagerStore(); const cacheService = createCacheService(); const userRepoMock = mock&lt;UserRepository&gt;({ getRolesQuery: () =&gt; cacheService.createQuery(['roles'], async () =&gt; ({ isAdmin, })), }); const billingRepoMock = mock&lt;BillingRepository&gt;({ getBillingInfoQuery: () =&gt; cacheService.createQuery(['billing'], async () =&gt; billingRepositoryFaker.makeBillingInfo(billingInfo), ), }); const sut = new BooksPolicyStore( policyManager, billingRepoMock, userRepoMock, ); await policyManager.prepareDataAsync(); return { sut }; }; describe('Добавление книги на полку', () =&gt; { it('Доступно администратору', async () =&gt; { const { sut } = await setup({ isAdmin: true }); expect(sut.addingToShelf.isAllowed).toBeTruthy(); }); }); });   Если не вызвать prepareData, то все доступы будут недоступны.  При тестировании отказа в доступе, необходимо проверять reason​  Тест-кейс Недоступно, если аккаунт не оплачен должен считаться пройденным только если reason соответствует PermissionDenialReason.NoPayAccount:  it('Недоступно, если аккаунт не оплачен', async () =&gt; { const { sut } = await setup({ isAdmin: false, billingInfo: { paid: false }, }); expect(sut.addingToShelf.isAllowed).toBeFalsy(); expect(sut.addingToShelf.reason).toBe( PermissionDenialReason.NoPayAccount, ); });   Финальный вызов allow или deny должен обрабатываться одним тест-кейсом​  public get addingToShelf() { return this.policy.createPermission((allow, deny) =&gt; { if (this.userRepo.getRolesQuery().data?.isAdmin) { return allow(); } const billingInfo = this.billingRepo.getBillingInfoQuery()?.data; if (!billingInfo?.paid) { return deny(PermissionDenialReason.NoPayAccount); } if ( billingInfo.info.shelf.currentCount &gt;= billingInfo.info.shelf.allowedCount ) { return deny(PermissionDenialReason.ExceedShelfCount); } // Этот allow будет иметь один тест-кейс allow(); }); }   Финальный вызов allow или deny должен аккумулировать условия, которые не описаны в коде:  it('Доступно, если аккаунт оплачен и не превышено максимальное количество книг на полке', async () =&gt; { const { sut } = await setup({ isAdmin: false, billingInfo: { paid: true, info: billingRepositoryFaker.makeBillingDetails({ shelf: { currentCount: 1, allowedCount: 2 }, }), }, }); expect(sut.addingToShelf.isAllowed).toBeTruthy(); });   Мотивация  Позволяет избежать роста количества тест-кейсов.  ","version":"Next","tagName":"h2"},{"title":"Тестирование Rules​","type":1,"pageTitle":"Принципы тестирования доступов","url":"/guides/docs/permissions/testing#тестирование-rules","content":" При тестировании rules необходимо:  Покрыть тестами положительные и отрицательные сценарии. Допустима группировкаПри тестировании отказа в доступе проверять reasonПоследний вызов allow или deny покрывать один тест-кейсом  export const calcAcceptableAge = ( acceptableAge?: number, userBirthday?: string, ) =&gt; createRule((allow, deny) =&gt; { if (!acceptableAge) { return deny(PermissionDenialReason.MissingData); } if (!userBirthday) { return deny(PermissionDenialReason.MissingUserAge); } if ( Math.abs(getDateYearDiff(new Date(userBirthday), new Date())) &lt; acceptableAge ) { return deny(PermissionDenialReason.NotForYourAge); } allow(); });   describe('calcAcceptableAge', () =&gt; { describe('Доступа нет', () =&gt; { it('Если нет данных о доступном возрасте', () =&gt; { const permission = calcAcceptableAge(); expect(permission.isAllowed).toBeFalsy(); expect(permission.reason).toBe(PermissionDenialReason.MissingData); }); it('Если у пользователя не заполнена дата рождения', () =&gt; {}); it('Если возраст пользователя не соответствует допустимому', () =&gt; {}); }); it('Доступ открыт, если есть доступный возраст + день рождения пользователя и возраст соответствует допустимому', () =&gt; {}); });   ","version":"Next","tagName":"h2"},{"title":"Тестирование UIStore, использующего permissions​","type":1,"pageTitle":"Принципы тестирования доступов","url":"/guides/docs/permissions/testing#тестирование-uistore-использующего-permissions","content":" Пример:  Реализованный UIStore использует permissions.books.addingToShelf. Логика формирования addingToShelf уже протестирована в permissions module, поэтому в UIStore необходимо протестировать только реакцию на разрешение и отказ в доступе:  export class UIStore { public isOpenAccountPayment = false; constructor( private readonly permissions: PermissionsStore, private readonly notifyService: Notify, ) { makeAutoObservable(this); } public addToShelf = (bookId: string) =&gt; { // Тест-кейс: Показывает информационное уведомление, если книга была успешно добавлена if (this.permissions.books.addingToShelf.isAllowed) { this.notifyService.info(`Книга ${bookId} добавлена на полку`); return; } // Тест-кейс: Открывает модалку оплаты, если было отказано в доступе с соответствующей причиной if ( this.permissions.books.addingToShelf.hasReason( PermissionDenialReason.NoPayAccount, ) ) { this.openPaymentAccount(); return; } // Тест-кейс: Показывает уведомление с ошибкой, если было превышено максимальное количество прочтений if ( this.permissions.books.addingToShelf.hasReason( PermissionDenialReason.ExceedReadingCount, ) ) { this.notifyService.error( 'Достигнуто максимальное количество книг на полке', ); return; } // Тест-кейс: Показывает уведомление с ошибкой, если было произошла непредвиденная ошибка при вычислении доступа this.notifyService.error( 'Добавить книгу на полку нельзя. Попробуйте перезагрузить страницу', ); }; public openPaymentAccount = () =&gt; { this.isOpenAccountPayment = true; }; public closePaymentAccount = () =&gt; { this.isOpenAccountPayment = false; }; }   Реализуемые тест-кейсы:  describe('GoodsListStore', () =&gt; { describe('Добавление книги на полку', () =&gt; { it('Показывает информационное уведомление, если книга была успешно добавлена', () =&gt; {}); it('Открывает модалку оплаты, если было отказано в доступе с соответствующей причиной', () =&gt; {}); it('Показывает уведомление с ошибкой, если было превышено максимальное количество прочтений', () =&gt; {}); it('Показывает уведомление с ошибкой, если было произошла непредвиденная ошибка при вычислении доступа', () =&gt; {}); }); });   ","version":"Next","tagName":"h2"},{"title":"Мок permissions​","type":1,"pageTitle":"Принципы тестирования доступов","url":"/guides/docs/permissions/testing#мок-permissions","content":" Для подмены permissions необходимо использовать mockDeep из библиотеки vitest-mock-extended и createDenialPermission из @astral/permissions:  import { mockDeep } from 'vitest-mock-extended'; import { createAllowedPermission, createDenialPermission } from '@astral/permissions'; describe('GoodsListStore', () =&gt; { describe('Добавление книги на полку', () =&gt; { const setup = (permissionsStoreMock: PermissionsStore) =&gt; { const notifyMock = mock&lt;Notify&gt;(); const sut = new UIStore(permissionsStoreMock, notifyMock); sut.addToShelf('id'); return { notifyMock, sut }; }; it('Показывает информационное уведомление, если книга была успешно добавлена', () =&gt; { // permissionsStoreMock делает addingToShelf доступным const permissionsStoreMock = mockDeep&lt;PermissionsStore&gt;({ books: { addingToShelf: createAllowedPermission(), }, }); const { notifyMock } = setup(permissionsStoreMock); expect(notifyMock.info).toBeCalledWith('Книга id добавлена на полку'); }); it('Открывает модалку оплаты, если было отказано в доступе с соответствующей причиной', () =&gt; { // permissionsStoreMock делает addingToShelf недоступным с причиной NoPayAccount const permissionsStoreMock = mockDeep&lt;PermissionsStore&gt;({ books: { addingToShelf: createDenialPermission( PermissionDenialReason.NoPayAccount, ), }, }); const { sut } = setup(permissionsStoreMock); expect(sut.isOpenAccountPayment).toBeTruthy(); }); }); });  ","version":"Next","tagName":"h3"}],"options":{"languages":["en","ru"],"id":"default"}}